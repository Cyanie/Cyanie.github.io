[{"title":"组合数学-生成函数的应用","date":"2017-08-13T12:05:00.000Z","path":"2017/08/13/Algorithms-Generation-function/","text":"母函数是解决计数问题强有力的工具。在OI中也时有出现，不学就跟不上时代了啊。 前置技能常见幂级数展开$$(1-ax)^{-1} = 1+ax+a^2x^2+a^3x^3+…$$ $$(1-x)^2=1+2x+3x^2+4x^3+…$$ 部分分式运用待定系数发将分式分解为若干个分式的和。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://cyanie.github.io/tags/笔记/"}]},{"title":"CodeForces泛做第一轮","date":"2017-08-08T00:08:08.000Z","path":"2017/08/08/Training-CF-Div2/","text":"由于博主太弱了，所以在NOIP2017之前开了这么一个坑，就这样吧。。 未完成: 546E 568C/D 571B/D CF573D 578D 582D 594B 601D 603B 605A 611E 613B 613D(虚树) Codeforces Round #301 (Div. 2)540C,4Y。BFS判连通。注意起始点与终点重合或相邻的情况，终点经过两次，只要有两个空格与终点相邻即可。 540D,1Y。概率DP。乘上转移的概率即可。 540E,3Y。离散化+树状数组统计逆序对。设出现的数为${a}$，未出现的为${b}$，发现a-&gt;a，a-&gt;b，b-&gt;a有贡献，分类讨论即可。 反思 把所有特殊情况考虑周全，仔细分类讨论。 Codeforces Round #302 (Div. 2)544C,1Y。二维完全背包DP。其实挺套路的，要加个滚动数组。 544D,1Y。暴力BFS。注意到两个点对的最短路径若存在交集，则一定是连续的一段。暴力枚举两点即可。 554E,1Y。状压DP。其实状压DP都挺套路的:①数据范围一般不超过20.②预处理加速转移.③转移时顺序无关，强制转移$lowbit$。 反思 注意观察题目性质，从多角度思考状态的表示。 Codeforces Round #303 (Div. 2)545C,4Y。贪心。注意到能往左倒就往左倒，否则能往右倒就往右倒，并不会使答案变差。注意$n=1$的情形。 545D,2Y。贪心。发现一定是$t$升序最优，对于一定不会满意的人，显然跳过放在最后最优。 545E,1Y。最短路DAG+DAG的最小树形图。由于数据范围过大，最小树形图并不能用朱刘算法来做。考虑是一个DAG，类似Kruskal依次加入权最小的边，保证弱连通块的入度为1.正确性不难感受到。 Codeforces Round #304 (Div. 2)546C,1Y。暴力。 546D,1Y。欧拉筛。考虑类似求积性函数的方式，可以推出每个数的素因子个数。 Codeforces Round #305 (Div. 2)548C,7Y。暴力求循环节+扩欧。坑点较多，注意分类讨论。 548D,1Y。单调栈或线段树。 548E,1Y。数论，容斥。考虑到一个数的素因子个数很少，直接暴力搜索容斥。 Codeforces Round #309 (Div. 1)553D,3Y。贪心。考虑现将所有的可以的点放入集合，每次取出权值最小的，更新周围点的权值。因为只有取出最小值，最小权才有可能变大。过程用堆维护即可。 Codeforces Round #310 (Div. 1)555D,2Y。贪心+堆。将问题转化为：给定一些数轴上的点，和一些线段，每个线段要匹配一个点。于是按照左端点不断加入线段，用堆维护右端最小的即可。 Codeforces Round #Pi (Div. 2)567E,1Y。最短路。首先求出最短路，反向建图后的最短路。注意到如果所有最短路都经过某一条边，那么相当于前驱最短路条数乘后继最短路条数等于总的最短路条数。如某一条边是最短路上的边，减一就可以满足条件。否则可以继续讨论。 567F,1Y。动态规划。注意到需要构造的序列是单峰的，所以考虑从小到大逐个加入两端。对于限制，DP到较大位置时判断即可。 反思 深入挖掘单调性(单峰亦同)寻找，寻找DP的阶段。 Codeforces Round #315 (Div. 1)568B,1Y。第二类斯特林数。注意到$n$等价关系能够对于到$n$完全图。于是答案即为，选取一些点(不能是全部)，划分为几个非空集合的方案数。假设选$i$个点，划分为$j$个集合，答案即为$C(n,i)\\times S(i,j)$。其中$S(i,j)$是第二类斯特林数，可以$O(n^2)$递推。 反思 从二元关系联系到图。 Codeforces Round #317 [AimFund Thanks-Round] (Div. 1)571A,2Y。正难则反+组合计数。有一个结论，将一个长度为$n$的序列划分为$3$个(可空)子序列，方案数为$\\large \\frac {(n+1)(n+2)} {2}$ 。加上不合法的方案，总方案即为$\\large \\sum \\frac {(n+1)(n+2)} {2}$。考虑减去不合法的情况，假设$a,b,c$伸长量分别为$x,y,z$，假设$a+x$最大。当$a+x&gt;=b+c+y+z$时不符，可以得到$b+c-a&lt;=x&lt;=l$，且$0&lt;=y+z&lt;=min(a+x-b-c,l-x)$，于是$y,z$的方案同样可以由上面的结论算出。 571B,6Y。同余分组+贪心+动态规划。考虑分为$K$组，所有$a\\equiv b\\pmod K$分为一组。设$d=n/ K$发现，前$n\\ mod\\ K$组都有$d+1$个数，后$n-n\\ mod\\ K$组都有$d$个数。排序后即可DP。 Codeforces Round #318 [RussianCodeCup Thanks-Round] (Div. 1)573A,5Y。暴力。考虑将所有数的素因子2,3都去除，判断是否相同。 Codeforces Round #319 (Div. 1)576B,1A。构造。首先将置换分解为若干个循环，注意到一个性质，长度为$x$的置换能连上长度$kx$的置换，只有长度为$2$的置换能自己连自己。且能作为根的只有长度为1或2的置换，分类讨论即可。 576C,1A。构造。考虑按$x$轴划分为$T$个区间，每个区间平均有$n/T$个，可以来回移动，最坏情况下有$T\\times[10^9+(n/T)\\times(10^9/T)]=10^9(T+n/T)$的移动距离，显然取$T=\\sqrt n=10^3$最优。 576D,1A。矩阵快速幂+floyd。考虑到$m$很小，可以逐个加边，用矩乘维护连通性，同时用floyd求连通后的最短路。矩阵乘法次数过多，会超时。但由于矩阵维护的是01信息，所以可以用$bitset$优化。 Codeforces Round #320 (Div. 1) [Bayan Thanks-Round]578A,1Y。公式。发现$a&lt;b$时无解，由于$x$要尽可能小，所以点一定都是在所有三角的右侧。根据$a/b$就可以算出属于第$t$个三角形。于是$\\large x=\\frac {a+b}{2t}$即可。 578B,1Y。贪心，暴力。考虑到$k$次操作一定是都乘在同一个数上最优，求出前缀和后缀$or$值即可。 578C,3Y。三分，贪心。考虑到答案是关于$x$的单峰函数（显然？），于是三分即可。可以同$O(n)$的贪心求出最大字段和。 Codeforces Round #321 (Div. 2)580E,3Y。HASH+线段树。发现[l,r]是周期为d的串等价于$S[l,r-d]=S[l+d-r]$，于是考虑维护区间的HASH值即可。 Codeforces Round #323 (Div. 1)582A,2Y。暴力+map。考虑每次取出最大的数$x$，一定是$a$中的元素，再将$x$与之前取出的$gcd$暴力删除即可。 582B,1Y。LIS变形。考虑保留出现次数最多的元素$x$，首先取出长度为$n^2$的段，求出$LIS$，发现$x$一定可以找到某个位置插入，所以还要加上$x(T-n)$。 583C,2Y。数论。对于好数组的元素$a[i]$有， $\\forall k\\in N, a[i]=a[i+kn],a[i]&gt;=a[i+ks]$ 。即$\\forall k \\in N,a[i]&gt;=a[i+k\\times gcd(s,n)]$。也就是说a[i]是这些a[]中的最大值。考虑枚举$d=gcd(s,n)$。求出$f[i]$表示以$i$结尾最长满足条件的长度，以及$cnt[i]$即$gcd(n,j\\times d) = d\\ (j&lt;=i)$的的个数。以$i$结尾，对答案的贡献即为$cnt[f[i]/d]$。复杂度$O(n的因子数\\times n)$。 Codeforces Round #325 (Div. 1)585A,1Y。模拟。用一个优先队列直接模拟即可。 585C,3Y。GCD。引入Stern–Brocot tree，将苹果数看作分子，橘子数看作分子，每次操作可以把$\\large (\\frac a b,\\frac c d)$变为$\\large (\\frac{a+c} {b+d}, \\frac c d)$或$\\large (\\frac a b, \\frac {c+a} {b+d})$。也就是它们的和在$Stern-Brocot\\ tree$上向左或向右移动。由于得到的分数一定是互质的，所以当$gcd(x,y)\\not = 1$时，没有答案。当$x&gt;y$时，会向左子树移动$\\large \\frac x y$次，之后$x\\ mod\\ y$会成为新的$x$。整个过程和求$gcd$类似，复杂度$O(log(x+y))$。 Codeforces Round #326 (Div. 1)587A,2Y。贪心。考虑逐个处理从小到大的$wi$，如果$wi=k$有偶数个，一定能组成$\\frac k 2$个$wi+1$，反之，能组成$\\frac {k-1} 2$个$wi+1$并需要用掉一个。 587B,4Y。DP。考虑将序列复制$k$次得到长度为$nk$的序列，然后DP加前缀和优化求出第$i$块第$j$结尾的方案数。多余的部分($T-nk$)答案等同于第$k$块。 587C,3Y。树上倍增。考虑到树上路径的问题，且不存在修改，考虑使用树上倍增。$g[i][j]$表示节点$i$到他的$2^j$的祖先，路径上最靠前的10个人被编号(注意去重)。合并的方式类似于归并排序。复杂度$O(10\\times nlogn)$。 Codeforces Round #327 (Div. 1)590A,4Y。题意：给定一个长为$n\\ (n&lt;=5\\times 10^5)$的01串，每次对于$2&lt;=i&lt;=n-1$，的$ai$会变成$a[i-1],ai,a[i+1]$的中位数。问经过多少次会变成一个稳定的串(即不会发生改变)。 构造。考虑长度为2或以上的0/1段一定是不变的，于是我们可以将中间的串单独提取出来，不难发现，由于不存在连续的串，一定是010101….(或101010….)这样的。最终的结果由两端决定。 590B,1Y。题意：要从$(x1,y1)$到$(x2,y2)$。一开始风速为$(vx,vy)$，$t$秒后$(wx,wy)$。速度不超过$Vmax$，求最少到终点的时间。保证风速小于你的速度，风速和你的速度都是向量。 二分答案。显然二分答案啊。事实上，可以看作空气是不动的，而目标点是逆风移动，对于答案$T$，只要新的距离$d&lt;=Vmax\\times T$即可。注意按照$T,t$的大小关系分类。 590C,5Y。题意：给定一个$N\\times M$的矩阵，这个矩阵里有’1’, ‘2’, ‘3’, ‘.’, ‘#’，可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，如果不能输出-1。其中’1’,’2’,’3’本身是连续的。$N,M&lt;=1000$ BFS+分类讨论。 考虑到答案只存在于两种情况。一种是三个连通块都会聚到一点。还有一种是两个连通块连向同一个连通块。于是BFS求出123到所有格子的最短距离即可。 590D,2Y。题意：给定$n$个数，最多相邻交换$s$次，求前$K$个数能达到的最小值。 动态规划。注意到一个性质，当$\\large s&gt;=\\frac {n(n-1)} 2$时，一定能取到$n$个数中最小的$K$个。定义状态$f[i][j]$表示固定前$i$个位置，交换$j$次能得到的最小的和。然后，为了取消后效性，依次考虑我们从1到n位置上的数。状态$f[i][j]$能转移到状态$f[i+1][j+k-(i-1)]$，$k$代表放在$i+1$位位置的数。 Codeforces Round #330 (Div. 1)594A,1Y。博弈，贪心。注意到后手一定会去掉最外层的$\\large \\frac {n-2} 2$个点，排序后扫描即可。 594C,2Y。暴力，贪心。显然我们只需要删除最左/上/右/下的点即可。考虑按$x,y$分别排序。因为$k$不大，所以我们暴力枚举两端取了多少，之后上下同样处理。注意长宽都至少是1。 594D,1Y。题意：给定$n$个数，有$Q$个询问，每个询问要求您回答$\\large \\varphi(\\prod \\limits ^{r} _{i=l} a[i])$的值。$n,Q&lt;=2\\times 10^5$ 离线，线段树，数论。考虑到$n,Q$的范围过大，我们考虑离线。 根据欧拉函数$\\varphi$的定义，$\\large \\varphi(n) = n\\times \\frac {p_1-1} {p_1} \\times \\frac {p_2-1} {p_2}\\times …$，我们只需要求出区间内有那些质因数一颗。考虑按照询问的左端点排序，扫描过程中维护区间$[l,n]$，对于区间$[l,n]$内的每一个质因子，我们只需要在线段树内保留最靠前的一个，因为后面对答案没有影响。 删除$[l]$时，我们只要对于$a[l]$的每个质因子找出它后面的第一个质因子，在线段树上更新即可。复杂度$O(a\\times loga+Q\\times logn\\times loga)$。 Codeforces Round #333 (Div. 1)601A,3Y。最短路。注意到由于是一个完全图，所以一定存在某一种交通工具可以直达，剩下一个交通工具floyd即可。 601B,1Y。题意：给定$n$个数字$h[1..n]$。定义$\\large L(h)=max \\lceil \\frac {|h[j]-h[i]|} {j-i} \\rceil$给定$Q$个询问，每个询问给定$li,ri$求$[li,ri]$所有子序列的$L(h)$之和。 单调栈。可以将$(i,h[i])$看作平面直角坐标系上的点。发现定义的就是两点间斜率的最大值。考虑不管这些点是凸或者凹的，斜率的最大值一定是由相邻的两个点产生的。于是，我们只需要用单调栈求出每个$h[i]$的作用域即可。 601C,3Y。题意：有$n$场比赛，每一场比赛都有$m$人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是$n$场比赛的分数之和。总排名定义为：总分严格小于他的人数+1。已知小K在n场比赛中的排名。所有人的水平相同，求小K的期望总排名。 期望DP。考虑到直接求出小K的排名过于困难，按照定义，只要求出总分严格小于他的期望人数。于是就想到，用$f[i][j]$表示$i$场比赛之后总分为$j$的期望人数。故有$\\large f[i][j]=\\sum \\frac{f[i-1][j-k]} {m-1} \\ (1&lt;=k&lt;=m, k\\not = a[i])$观察式子，考虑到可以前缀和优化转移。 Codeforces Round #334 (Div. 1)603A,1A。贪心，DP。观察到，一个位置对答案产生了贡献，当且仅当这个位置的数与前面一个数不同。又由于只能翻转连续一段，所以DP时定义三种状态即可。 603C,3A。博弈论+SG函数。考虑引入SG函数，当$i$为奇数时，$SG[i]=mex{ SG[i-1]}$。当$i$为偶数时，能够进行第二种操作，$SG[i]=mex{SG[i-1], SG[i/2]\\ xor\\ SG[i/2]… }$，共有$k$个SG[i/2]的异或和，注意到这只和$k$的奇偶性有关。 考虑寻找规律。当$k$为奇数时，由于$SG[i]=mex{ SG[i-1], 0}$，所以之后的$SG[i]$一定是0/1间隔出现的。当$k$为偶数时，$SG[i]=mex{ SG[i-1], SG[i/2]}$，并且注意到$i$为奇数时，$SG[i]=0$，所以只要$log\\ a[i]$次递归调用即可。 Codeforces Round #335 (Div. 1)605A,1A。题意：给定$n$的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤。 贪心。考虑那一段是可以不用变化的，发现就是数字连续上升的最长字段（例如,..,1,2,..,3,..,4,…）于是$O(n)$扫一遍即可。 605B,1A。题意：有一个$n$个点，$m$条边的图，然后$m$条边中有$n-1$条边构成了最小生成树，然后边权与是否作为MST的边告诉你，要构造出这个图。 最小生成树的性质，贪心。考虑首先构造出他的最小生成树，再往上面加边。考虑到最小生成树的边不能被新加入的边$(u,v)$代替，所以需要$u,v$之间的路径的边尽可能少，所以可以强制$root=1$剩下的$n-1$个点直接连到$root$。将最小生成树的边与其他边按照边权排序。 每加入一条MST的边，可以与前面的节点产生一些新的点对，由于边权是升序的所以之后的其他边一定不会产生冲突。注意我们只需要保留最小的$m$条即可。 605C,3A。题意：有$n$项工作，第$i$项工作每天可以带来$ai$的经验，$bi$的钱。问最少几天可以得到$p$的经验和$q$的钱。工作天数可以是小数，每次只能进行一种工作。 二分答案，凸包。首先考虑二分答案$T$。如何$O(1)$来check？我们将$(ai,bi)$看成坐标系上的一个点$Pi$，由于工作时间可以是小数，通过线性变换，$Pi,Pj$可以变换为线段$PiPj$上的点。所以可以先求出凸包，然后二分答案判断即可。 605D,1A。题意：玩家有两个属性$x,y$，有$n$个魔法。对于第$i$个魔法，用$(ai,bi,ci,di)$描述。当$ai&lt;=x, bi&lt;=y$时，玩家能使用这个魔法。之后玩家的属性$x=ci, y=di$。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。 线段树（树状数组）+set，BFS。由于需要求出最小的步数，所以需要用到BFS。考虑到达了点$(x,y)$，我们可以到达在它左下角的点$(x’,y’)$，所以就需要用一个数据结构求出。树套树显然可以，不会写。考虑线段树（树状数组）套set。","tags":[{"name":"训练","slug":"训练","permalink":"https://cyanie.github.io/tags/训练/"}]},{"title":"","date":"2017-08-06T01:58:47.430Z","path":"2017/08/06/Training-DP/","text":"","tags":[]},{"title":"组合数学-Burnside引理与Polya定理","date":"2017-08-05T12:05:00.000Z","path":"2017/08/05/Algorithms-Group-theory/","text":"更多的坑待填… 参考资料 说明 在OI中群论主要用于等价类计数，其中Burnside引理与Polya定理是其核心。 一些定义及定理群。群$G$是一个定义在二元组$(S,⋅)$的代数结构，$⋅$是一个二元运算符。满足封闭性(任两个元素能推到另一个元素)，结合律，消去律。存在单位元$e$，并且每个元素都有逆元。 置换。$(a_1,a_2,a_3,…,a_n)$即$(1,2,3,4,…,n)$的一一映射（全排列），把$i$映射到$a_i$。任意一个置换都可以写成循环的形式：$(3,5,1,4,2)=(1\\ 3)(2\\ 5)(4)$。 置换群，即由置换组成的群，运算是置换的连接。 Burnside引理。用于求置换下的等价类个数。设$G={f_1,f2,…f{|G|}}$是$[1,n]$的置换群。一个方案$S$在置换$f$的作用下不变，称$S$为$f$的不动点，$fi$的不动点个数记为$c(i)$。于是，$$\\Large ans=\\frac{\\sum {i=1}^{|G|} c(i)}{|G|}$$。 Polya定理。 如果置换$f$分解为$m(f)$个循环，每个循环的颜色都相同，若存在$k$种颜色，即有$c(i)=k^{m(f)}$。带入Burnside引理即得。 一些推论及技巧$c(i)$可以通过组合计数，DP或数论的方式求出。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://cyanie.github.io/tags/笔记/"}]},{"title":"图论-prufer序列与矩阵树定理","date":"2017-08-04T10:00:00.000Z","path":"2017/08/04/Algorithms-Tree-count/","text":"更多的坑待填… prufer序列参考资料 prufer序是无根树的编码表示，对于一棵$n$个节点带编号的无根树，对应唯一一串长度为$n-2$的prufer编码。 无根树转化为prufer序列找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下$2$个节点。 根据以上过程，显然有推论 一个节点的度数=其在prefer序列出现的次数+1。 prufer序列转化为无根树首先prufer序列中的出现次数+1可以得到每个节点的度。 先执行$n-2​$步，选取最小标号度为1的点$u​$与Purfer序列的第$i​$个数$v​$表示的顶点相连，并将$u​$和$v​$的度减$1​$。最后再把剩下的两个度为$1​$的点连边。 由此发现，一棵无根树和与一个prufer序列一一对应。 一些推论 一个无向完全图的生成树个数为$n^{n-2}$。 设节点$i$的度数限制为$di$，求满足条件树的个数。对应到prufer序列，相当于$i$在序列中出现了$di-1$次，不同的排列数。即为$n!$除以每个$(di-1)!$。 对于一些没有限制度数，稍微修改一下即可。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://cyanie.github.io/tags/笔记/"}]},{"title":"AtCoder泛做-ARC#068~076","date":"2017-07-14T16:00:00.000Z","path":"2017/07/15/Training-ARC-068-076/","text":"未完成: ARC#069F, ARC#070E/F, ARC#074F AtCoder Regular Contest 068 E - Snuke Line 给定$n$个区间$[l,r]$和一个数$m$。对于$d=1,2,3…,m$，求$kd(1&lt;=kd&lt;=m,k\\in Z)$被多少个不同区间覆盖（对于不同的$k$，只算一次）。$1&lt;=n,m&lt;=3\\times 10^5,1&lt;=l&lt;=r&lt;=m$ 记区间的长度为$len=r-l+1$。想到可以$O(mlogm)$暴力枚举所有的$kd$，用线段树算出它被几个区间包含。容易发现当$d&lt;len$时，有可能被多次计算。 考虑当$d&lt;=len$时，则一定存在$k$使得$kd$被这个区间覆盖。于是我们记录满足$d&lt;=len$的区间个数即可。而对于$d&gt;len$的情况，至多有一个$kd$被区间覆盖，于是就可以用线段树维护。即当$d&gt;len$时加入这个区间，同时单点询问$kd$被多少个区间覆盖。复杂度$O((mlogm+n)logm)$。 Code F - Solitaire 有一个双端队列，依次往首或尾插入数1到n。然后你可以从队列的首或位取出一个数，顺次相接组成一个序列。求有多少个序列的第$K$位为$1$？$1&lt;=k&lt;=n&lt;=2\\times 10^3$ 显然，当$n$个数全部插入后，队列一定是递减到1再递增的。不难发现，得到的序列的前$K$位，一定是由两个递减序列交错得到的，且第$K$位为1。 从$n$到$1$逐个考虑每一个数是否选择，且属于哪一个序列。定义$f(i,j)$ 已经得到了序列的前$i$位，其中第$i$位为$j$的方案数。将$j$加入序列1，则$f(i,j)$可由$f(i-1,k), k&gt;j$转移过来。 如果将新的数加入序列2，该如何转移？可以发现，这个数一定是没选择的数中最大的数（序列2也是递减的）。则$f(i,j)$可由$f(i-1,j)$转移过来。 事实上，DP的过程还有一个非法的转移。$f(K-1,1)$会转移到$f(K,1)$，不是以1作为第$K$个数。 对于剩下的$n-K$个数，每次可以取头或尾。于是答案$ans=(f(K-1,1)-f(K-1,1))\\times 2^{n-K-1}$。 时间复杂度$O(nK)$。 Code AtCoder Regular Contest 069 E - Frequency 有$n$堆石头，第$i$堆有$ai$个石头。每一次，你需要记录下石头最多的堆的序号（当石头数相同时，取最左端的），然后你可以从某堆中拿走一块石头。直到石头被全部拿走。需要使得序号组成的序列字典序最小，问1到n在序列中出现的次数。 可以发现，这个序列一定是非递增的。假设现在最多的石头堆为$x$，在1到x-1中石头最多的堆为$y$。考虑贪心的过程，我们需要把x到n中，石头数大于$ay$都取到$ay$，因为这样能使得序号尽可能快地减小。离散化石头数，再从小到大考虑，用树状数组维护小于某个值的石头堆数量，以及石头数总和即可。 事实上，存在排序后$O(n)$的做法。 Code F - Flags 你在一条线上插$n$个$flag$，其中第$i$个$flag$可以插在$xi$或$yi$。记所有$flag$两两间的距离最小值为$d$，求$d$的最大值。 暂未编写。 考虑二分答案$d$。于是是否放在$xi,yi$变成了$2-SAT$判定性问题，对于$xi$和$yi$恰好放一个，距离小于$d$的位置不能同时放，构成了一些约束条件。暴力枚举所有点对，可以在$O(n^2logMAX_{x})$的时间内解决。 发现许多约束条件是无用的。考虑类似线段树的分治结构来建图，对于每个点，至多与$O(logn)$个区间相连；令一方面，线段树中父子相连的边也只有$O(n)$条。单次判定的复杂度可以做到$O(nlogn)$。总的时间复杂度$O(nlognlogMAX_{x})$，可以通过此题。 存在$O(n(logn+logMAX_x))$的算法，暂未理解。 AtCoder Regular Contest 070 D - Need 给定$n$个数$ai$。如果存在子集满足其和大于等于$K$，则称为是好的子集。如果一个数$ai$所在的所有好集中，去除$ai$后仍是好集，则$ai$是无用的。求无用的数的个数。 对于$x&lt;y$，若$y$是无用的，则$x$一定无用的，所以答案满足单调性。考虑判断$x$是否是无用的，用$bitset$维护$n-1$个数相加能组成的集合（$x$除外，可以用类似$DP$的方式求出）。 显然，如果其他的数能组成$K-x$到$K-1$中的任意一个数，则$x$是有用的。时间复杂度$O(\\frac {n^2logn} w)$ ，此处$w$一般为$32$或$64$。 Code AtCoder Regular Contest 071 E - TrBBnsformBBtion 有字符串$S,T$，仅由$A$或$B$构成。有如下操作：①选择一个字符:$A\\rightarrow BB$ 或 $B\\rightarrow AA$。②删除连续3个相同的字符:$AAA$或$BBB$。给定$Q$个询问，对于每个询问，回答$S[a,b]$能否变换为$T[c,d]$。$|S|,|T|,Q&lt;=10^5$ 想了几分钟就YY了一个结论：把A看作1，把B看作2，两个串能变换当且仅当两个区间和模3同余。然后就A掉了。首先，必要性显然，因为对于区间和模3，不论如何操作都不会改变。 看了官方题解才知道如何证明充分性。首先主要到所有的操作都是可逆的：$A\\rightarrow BB\\rightarrow AAAA\\rightarrow A$。且$A,B$可以任意地加3个或减3个。考虑将$S$和$T$中的$B$全变为$A$。如果$S,T$的$A$个个数关于3同余，则一定能变换。就证明了结论。 Code F - Infinite Sequence 给定$n\\ (n&lt;=10^6)$，问存在多少个无穷序列满足：1.每个数都在1到$n$之间。2.对于任意$n&lt;=i,j$，都有$a_i=a_j$。3.对于任意的$i$，若存在$i+1&lt;=j&lt;k&lt;=i+a_i$，都有$a_j=a_k$。 发现只有前$n$位是有用的，考虑到动态规划更容易向前转移，定义$f(i)$为子序列$[i,n]$满足条件的个数，于是我们考虑$a_i$的值即可转移。 发现1是一个比较特殊的数，当$a_i=1$时，$f(i)=f(i-1)$。 当$a[i]\\not=1,a[i+1]\\not=1$时，序列为$ABBBBBB…$的形式，$f(i)=(n-1)\\times (n-1)$。 当$a[i]\\not=1,a[i+1]=1$时，序列为$A,1,1,,..,1,B…$的形式，$f(i)=f(i-3)+f(i-4)+…+f(1)+n-i+2$。 Code AtCoder Regular Contest 072 D - Alice&amp;Brown A和B在玩一个游戏。一开始，有两堆石子分别有$X$和$Y$个。你可以从一堆中取$2i$个，然后放$i$个到另一堆。无法操作的玩家输。问先手是否存在必胜策略?$0&lt;=X,Y&lt;=10^{18}$。 通过打表发现，当$|X-Y|&gt;=2$先手必胜，否则后手必胜。考虑如何证明。 对于$(X,Y)=(0,0),(0,1),(1,0),(1,1)$，满足$|X-Y|&lt;=1$，是必败态。 对于必胜态，设$|X-Y|=3k+r&gt;=2\\ (r=0,1,-1,\\ k&gt;=1)$ ，取$i=k$，即可转移到必败态。 对于必败态，操作后$X-Y$至少改变3，一定会转移到必胜态。 Code E - Alice in linear land 给定长度为$n$的操作序列$ai$和距离$di$。对于每个$ai$，当$|d-ai|&lt;d$时$|d-ai|$会成为新的$d$，若最终$d=0$，则称是可达的。给定$Q$个询问$qi$，问能否改变$a[qi]$，使得操作序列是不可达的？$n,Q&lt;=5\\times 10^5$ 首先可以预处理前缀$a[1,qi-1]$操作后的$d$，记为$pre[qi-1]$。发现对于询问$qi$，只需要知道后缀$a[qi+1,n]$使得序列不可达的最小的$d=suf[qi+1]$，只要$pre[qi-1]&gt;=suf[qi+1]$就一定能做到。 于是问题转化为如何就$suf[i]$。显然，$suf[n+1]=1$，而且随着$i$的减小，$suf[i]$一定是非递减的。当$ai&gt;=2\\times suf[i+1]$，可以取到$suf[i]=suf[i+1]$（此时无法执行操作）；否则$suf[i]=suf[i+1]+ai$。 Code F - Dam 有一个水坝容积为$L$，一开始没有水。此后$n$天，在第$i$天早晨，会进来体积为$Vi$，温度为$Ti$的水；为了下一天水不会溢出，第$i$天傍晚需要排出一些水。对于体积$V1$，温度$T1$和体积$V2$，温度$T2$的水混合，体积为$V1+V2$，水温为$\\large \\frac {T1\\times V1+T2\\times V2}{V1+V2}$。回答$n$个询问，对于第$i$个询问，输出在第$i$天能够达到的最大水温。$n&lt;=5\\times 10^5$ 假设混合得到的水体积为$V2$，温度为$T3$。由题目可知$T1\\times V1+T2\\times V2 = T3\\times V3$。考虑将$(x,y)=(V,TV)$抽象为一个向量，那么，水的混合就变成了向量之和！ 观察这个向量，发现$T$对应的就是它的斜率！将水排出，相当于是原向量乘上&lt;1的实数！将可能的状态画在坐标系上，可以发现这一定是一个上凸包。如图。 而新加入一个向量后，最右端的会被删除。此时不一定还是凸包，在左端比较相邻的斜率，合并即可。 整个过程用双端队列维护，复杂度$O(n)$。 AtCoder Regular Contest 073Code E - Ball Coloring 有$n$个包，每个包里各有两个球，权值为$xi$和$yi$。你需要将一个球涂为红色，另一个球涂为蓝色。令$Rmin$为红球中的最小权值，$Rmax,Bmin,Bmax$同样定义。求出$(Rmax-Rmin)\\times (Bmax-Bmin)$的最小值。$n&lt;=2\\times 10^5$ 假设所有权值中的最大值为$Max$，最小值$Min$。不失一般性地，有两种情况： $Rmax=Max,Bmin=Min$，此时需要最大化$Rmin$，最小化$Bmax$，于是将两个球中较大的涂为红色，较小的涂为蓝色。 $Rmax=Max,Rmin=Min$（Min和Max不在同一包里），此时需要最小化$Bmax$，最大化$Bmin$，令$xi&lt;=yi$，之后按照$x$升序排序。我们说，最优方案一定是，排序后，前$k\\ (1&lt;=k&lt;=n)$个的$xi$涂为红色，后$n-k$个涂为蓝色。如何证明，考虑反证法。 假设第$p(p&gt;=k+2)$涂为了红色，那么$Bmin$并不会增大，而$Bmax$并不会减小，所以一定不会是更优解。于是简单证明了结论。 Code F - Many Moves 在一根长度为$n$的数轴上，有两个方块，位置为$A,B$。并且在同一时刻，你能移动一块方块一个单位距离。你需要依次到达位置$xi$，求最少所需时间。$n,Q&lt;=2\\times 10^5$ 以$xi$作为阶段，注意到上次的一个方块位置一定是在$x[i-1]$，于是不难想到$O(n^2)$的DP。$f[i,j]$表示到位置$xi$，另一个位置为$j$的最小时间。若原来位置为$x[i-1]$的到位置$xi$，即有$f[i,j]=f[i-1,j]+|x[i]-x[i-1]|$。否则即有$f[i,x[i-1]]=f[i,j]+|j-x[i-1]|$。 考虑如何从优化转移的时间。对于前面的状态转移方程，事实上就是线段树的区间加。对于后面的状态转移方程，考虑维护$f[i,j]-j$和$f[i,j]+j$的值，在$[1,x[i-1]]$取$f[i,j]-j$的最值；在$[x[i-1],n]$取$f[i,j]+j$的最值即可。阶段间的转移优化到了$O(logn)$。 Code AtCoder Regular Contest 074 D - 3N Numbers 给定$3n$个数$A$，你需要删除其中的$n$个数，使得剩下$2n$个数$A’$中前$n$个数之和-后n个数之和之差最大。求最大值。$n&lt;=10^5$ 发现对于删除后$A’$的第$n$个数一定是在原来$A$的$[n,2n]$，考虑暴力枚举$A’[n]$的取值，剩下的贪心地选取。整个过程用堆维护。 Code E - RGB Sequence 您需要构造一个长度为$n$， 由R,G,B构成的序列，满足以下$m$个限制。对于限制$i$，满足$[li,ri]$间不同的颜色种数恰好为$xi$。求满足条件的序列数。$n,m&lt;=300$ 考虑到如果存在不满足的情况，一定是DP过程中最后的R,G,B发生冲突。于是考虑状态$f[R][G][B]$表示$R,G,B$最后的位置，发现当前位置$p=max{R,G,B}$。考虑暴力转移，转以后判断是否冲突即可。 Code AtCoder Regular Contest 075 D - Widespread 有$n$只怪兽，第$i$只怪兽初始血量$hi$。每次可以选定一只怪兽攻击，造成$A$点血量的伤害。同时其他怪兽受到$B$点血量的伤害。求最少的攻击次数。$n&lt;=100000$ 考虑二分答案次数$T$。当某只怪物的血量$hi&lt;=BT$时，不需要主动攻击。否则需要$\\large \\lceil \\frac {hi-BT} {A-B}\\rceil$次主动攻击，判断主动攻击次数之和是否不超过$T$次即可。 F - Mirrored 对于一个正整数$n$，记$rev(n)$为$n$的倒置，例如$rev(123)=321,rev(4000)=4$。给定$D$，求存在多少$n$满足$rev(n)=n+D$。$D&lt;=10^9$ 以5位数为例，$\\overline{edcba}-\\overline{abcde}=9999(e-a)+990(d-b)$ 考虑到如果$D$不是9的倍数，一定无解，否则我们考虑现将$D$除以9。然后DFS，发现$(e-a)\\ mod\\ 10$可以确定，同样可以逐位确定剩余的位，最后乘法原理确定总方案数即可。注意奇偶分类。","tags":[{"name":"训练","slug":"训练","permalink":"https://cyanie.github.io/tags/训练/"}]},{"title":"2017年7月NOIP集训总结","date":"2017-07-02T12:00:00.000Z","path":"2017/07/02/2017.7-Training/","text":"暑假终于到了，蒟蒻$Cyani$也要开始刷题啦~ 暑假的训练时光是宝贵的，是算法和思维快速提高的时期，在这里总结下收获。 7.2-基础数据结构单调栈&amp;单调队列单调栈应用： 求出一个数左/右第一个比这个数大/小的数。 BZOJ1136：[POI2009]求序列中的最长连续子序列，其平均数大于$k$。 考虑每个数都减去$k$，转化为区间和&gt;=0的最长区间。求前缀和后，若$i &gt; j$且$sum_i&gt;=sum_j$，则$j$作为左端点比$i$更优。 维护一个$i$递增$sum_i$递减的栈。枚举右端点，利用单调性二分找到小于它的节点。 事实上，右端点从$n$向左枚举，小于等于它的节点都可以弹出（右端点左移后，长度只会更劣）。 HDU5726：[多校2016]对于给定序列$A$，和$Q$组询问$(l,r)$。输出$gcd(al,al+1,…,ar)$ 和所有满足$gcd(al,al+1,…,ar)=gcd(al0,al0+1,…,ar0)$ 的$(l0,r0)$的个数。 $gcd$有一个很神奇的性质，不断对某个数取$gcd$，得到不同的值最多有$log$个。考虑右端点不断向右移，维护$gcd$区间的单调栈，加入新的数后不断合并相同的数。 考虑第一个问题，将所有询问挂在右端点，对于左端点排序，之后在单调栈里扫一遍就好了。 考虑第二个问题，用一个$map$存所有出现的$gcd$个数。单调栈同时保存所在下标，单调栈扫一遍，下标作差就是贡献。 51Nod1962：给出两个数组A，B，求$Σ︀max(Ai,Ai+1, …,Aj)==max(Bi , Bi+1, …,Bj)(1&lt;=i&lt;=j&lt;=n)$的值。 暂未AC。向右移动一个端点时，前一次的答案可以利用。维护单调栈时，也维护区间即可。 单调队列应用: 维护DP决策点，删除不可能的决策。 CF524F：给出一个仅由’(‘和‘)’构成的字符串，现在可以加入一个字符，或者将末尾的字符移到最前面。求一个长度最短的合法括号序列，如果有多个输出长度最短的且字典序最小。 暂未完全理解。这题的正解是后缀数组或者HASH+二分，复杂度$O(nlogn)$，然而我并不会。然后zyy大神犇用单调队列，(si hu)复杂度$O(n)$就过去了，做法还是很神的。首先答案一定是原长加上两种括号的差值，（这个是一定能完成的，并且’(‘加在最前面，’)’加在最后面）。那么我们可以将串倍长，计算每个长度为n的区间是否将会缩成一种括号。 考虑计算那些为位置可以作为左端点，如果说一个括号序列是可以匹配的，当且仅当“所有位置的前缀’(‘数量大于’)’的数量“。维护’)’与’(‘差值的前缀和单调递减，每次可以找到’)’减去’(‘最大的右端点，若这个值大于要加上的左括号的数量，则这个位置开始是不符的。$O(n)$内就能算出每个位置是否能作为左端点。 接下来就是些很神奇(sang xing bing kuang)的操作，比较以这些左端点所在的区间的字典序，乱搞一下就行了？复杂度又似乎$O(n^2)$？反正没搞懂。。 字符串这一部分考的主要是KMP的灵活应用和对$Nex$t数组的理解（如经典的把匹配位置作为状态的DP）。 CF631D：给出两个串$A$,$B$，问$B$在$A$中出现了多少次。字符串由$n$个二元组$(li,ci)$拼接而成，每个二元组代表$li$个字符$ci$。 考虑去除$B$前后的二元组，中间的用KMP匹配，两边的再特殊判断。特判只有一个或两个二元组的的情况。 Hash原来我对哈希的理解仅在”一堆数加起来模个质数”的层面。。 把所有数据都$xor$起来，这种方法适用于数据不需要维持相对顺序的时候。 转化成一个$seed$进制下的数模一个质数的值，是可以支持询问一个区间的值，拼接若干区间，以及插入，删除，修改之后的全局询问。 CF7D：定义一个串是$k$回文的，当且仅当这个串是回文的，且其长为$⌊n/2⌋$的前后缀都是$k − 1$回文的，任意串都是$0$回文的。判断这个串的每个前缀的最大回文数. 考虑直接DP。如果$[1,i]$是回文的就有$fi=f{i/2}$，否则为0。考虑维护左端和右端的HASH值，用第二种方式可在两端插入和删除，判断是否相等即可。 CF452F：给定一个$n$的置换$A$，问是否存在一个三元等差子序列。 哈希+线段树。对于中间的数$x$，若不存在$x-k$和$x+k$构成了等差数列，则$x-k$和$x+k$一定在都在$x$之前或之后。于是维护以出现的数，若出现的数关于$x$不对称，一定存在一个等差数列。用线段树正反各维护HASH的值，判断是否相等即可。用第二种HASH方式。 差分这是NOIP喜欢考的小技巧。 序列差分，将区间加变成单点加减，只能做到离线。 树上差分，一般和LCA结合。在u,v处打标记，在LCA处消除标记，求其子树的标记和即可。对于一些树上路径问题，可以用差分代替树链剖分。 BZOJ3043：给定数列A，每次可将区间+1或-1。至少多少次使得所有数相同，在此条件下最终的数列有多少种。 将所有数差分，可将题目中的区间加减变为单点加减。考虑差分的性质：若要操作$[l,r]$，当$r$不为$n$时，在$l$处打$+1/-1$标记，在$r+1$处打$-1/+1$；仅当$r=n$时，在$l$处打$+1/-1$。于是求出差分数组正数的和$x$，负数的和的绝对值$y$。然后$x,y$互相抵消，多余的自己抵消或和第一个抵消。操作次数为$max(x,y)$，结果数为$abs(x-y)+1$。 树上差分的经典题：[NOIP2015]D1T3运输计划，[JLOI2014]松鼠的新家 7.3-树相关1倍增倍增也是noip的常考点，往往可以优化为$log$或去掉一个$log$。 假设现在有问题$f(N)$，如果我们可以通过$f(A)$和$f(B)$快速求出$f(A+B)$，则我们就可以倍增。二进制拆分为$log$个答案，再合并就是最终答案。e.g.快速幂，多项式乘法(FFT?)，RMQ求区间最值，树上节点的祖先。 优化二分。对于一些具有单调性的问题，我们可以二分答案，再用倍增求，复杂度$O(lognlogn)$ 。事实上可以用倍增优化二分，复杂度降到$O(logn)$ 。 假设二分的区间是$[0,n]$，设$m=log(n)$。 设答案$ans$一开始为0，先检验$ans+2^m$是否满足条件，如果满足则让$ans+=2^m$。 之后让$m–$，一直做到$m=0$为止。 正确性显然，相当于二进制逐位确定最终的$ans$。 利用倍增估计二分的界限，来优化一些奇怪的二分？ HDU4343：给定$n$个区间，有$m$次询问，每次问最多可以从n个区间中选出多少$[L,R]$的子区间，使得他们互不相交。 首先去除包含其它区间的区间（显然选择更小的区间更优），所以左端点和右端点都是递增。考虑贪心的过程，每次要选择左端点&gt;=当前右端点，且最靠左的区间。预处理所有区间的后继，然后算出倍增数组。对于每个询问，找到区间内最靠左的区间，倍增找到最靠右的区间，每次询问复杂度$O(logn)%$。 HDU6031：给定一棵$n$个点的有根树，有$Q$次询问，每次询问给出一个集合$A$和集合$B$，你需要从$A$中选出一个数$x$，从$B$中选出一个数$y$，使得$lca(x,y)$的深度最大。 二分答案的深度$s$，求出$A$中点的深度为$s$的祖先和$B$中点的深度为$s$的祖先。用$map$判断两个集合是否有交即可。 DFS序把对子树维护的问题转成对区间维护的问题，记录DFS进入和出去的时间。$y$在$x$的子树中的充要条件是：$in[x]&lt;=in[y]&lt;=out[y]&lt;=out[x]$。 转化为区间维护问题后，用树状数组或线段树维护即可。一般难度不大。 树的路径相关 将路径拆分为x到$LCA$，和$LCA$到y的两条链。 定义一个点的重量是去掉它之后树的最大的联通块的大小。我们将一棵树中重量最小的点称为重心。一棵树最多只有两个重心。 判断无根树同构：取重心作为根，从而变成有根树，然后就可以用树hash来判断是否同构了。 点分治：重心的重量一定小于等于$n/2$，所以可以用来分治。 定义一棵树中最长的路径为树的直径。树的直径并不唯一，但是直径的中点都是一样的。 任选一个点$S$，找到离他最远的点$X$。找到离$X$最远的点$Y$。那么$(X,Y)$就是一条直径。 直径合并：对于两棵树$T,S$，任取他们的直径$(Ta,Tb)$，$(Sa,Sb)$。假设现在有一条边连接了$T$和$S$，构成了新的树$M$，那么$(Ta,Tb,Sa,Sb)$这四个点中一定能选出两个点$u,v$，使得$(u,v)$是$M$的一条直径。 对于一些要你在树上选两个点的题，可以先打表看看，很大概率是选在直径上最优。 并查集 路径压缩：与树的形态无关，尽量将儿子节点挂到根节点上，均摊复杂度$O(α(n))$，单次可能被卡到$O(n)$！ 按秩合并：与树的形态有关，记一下每棵有根树的子树大小，每次合并时让小的成为大的的儿子。树高一定是$O(logn)$。复杂度证明：从一个点x出发，每次往上爬，子树大小至少翻一倍。所以最多爬$O(logn)$次。 CF468B：给定$a,b$和$n$个整数。每个整数属于集合$A$或$B$。如果$x$属于集合$A$，那么$a-x$也属于集合$A$；如果$x$属于集合$B$，那么$b-x$也属于集合$B$。判断是否冲突 考虑其逆否命题，$a-x\\notin A\\Rightarrow x\\notin A$ ，可以确定某些整数能否属于集合$A$，集合$B$同样处理。同时将$x$与$a-x$合并，或上1表示能在集合$A$，或上2表示能在集合$B$。最后判断同一个并查集里的是否有冲突即可。 7.5-膜你赛1题目很赞，数据略水，还是很滋瓷的。T1暴力A掉，T2写出正解，T3正解写挂。。全场Rank5？？ A:分块 给定序列$a1,a2,…,an$和$Q$个询问。对于询问$(q,p)$求出所有满足$i=p(mod\\ q)$的$ai$之和。$n,Q&lt;=100000$ 暴力对于数据随机，均摊复杂度可以达到$O(nlogn)$（调和级数）。 发现暴力速度的瓶颈在于$q$较小的情况。考虑设置一个阀值$k$。 对于$q&gt;=k$的情况，直接$O(n/k)$就可以暴力算出答案。 对于$q&lt;k$的情况，$O(kn)$就可以预处理答案。 复杂度$O(kn+n^2/k)$，显然取$k=\\sqrt n$最优。 B:函数相关？脑洞题 给定一个$n$行$m$列的矩阵（所有的元素都在模$K$意义下操作），可以有以下操作：修改某一行，使得这行所有的数累加1；列也是类似操作。求出最少要操作几次，使得矩阵全为0（保证存在解）。$n,m&lt;=1000$ 假设第$i$行的操作次数为$xi$，第$j$列的操作次数为$yj$。显然$0&lt;=xi,yj&lt;K$。 不难发现当第一行的操作次数（记为$x$）确定后，所有行和列的操作次数都能确定，且都是关于$x$的线性函数。 所以操作次数$ans=f(x)$是关于$x$的分段函数，每一段都是一次函数。 发现一次函数的最值一定是在端点处取到，而端点取到的情况是某个$xi$或$yj$等于$K-1$或$0$。 带入$x$，直接$O(n)$就能算出$f(x)$，于是复杂度为$O(n^2)$。 C:数据结构 有$𝑛$个墙，第$𝑖$个墙的高度为$𝑎𝑖$，给你$𝑄$个操作。$𝑃$，询问当前墙的状态下最多能存储多少水。$𝑈(𝑥,𝑣)$，令第$x$个墙的高度增加$v$。$n,Q&lt;=100000$ 考虑暴力的做法。为了方便计算，我们需要把砖块当作“水”，同时维护砖块的个数。显然我们一定可以找到最高且最靠右的墙（记为$P$），而左边水的高度是单调不减的，右边水的高度是单调不增的。 直接$O(1)$维护墙的高度。对于每一个询问，从$1$扫描到$P$，维护前缀最大值，每个位置水的高度都是前缀最大值；同理从$n$扫描到$P+1$即可。需要减去砖块的个数。 标程的做法：以$P$左侧为例。用$set$维护高度递增的墙。当$x$高度增加需要更新后，弹出在$x$右侧且比它低的墙，在此同时，维护水的个数即可。注意到$P$位置是可以改变的，需要特殊处理。由于进入$set$的元素个数为$O(n)$，并且$set$单次操作时间为$O(logn)$。复杂度$O(nlogn)$。 我的做法：用线段树维护。当$x$的高度增加需要更新后，区间更新$[x,P]$的最大值。即仅当$ax&gt;ai(x&lt;=i&lt;=P)$后，才会更新$ai$的值。似乎需要$O(n)$？ 事实上，由于单调性的存在，对于每个线段树区间$[l,r]$，维护左端高度$lh$，右端高度$rh$。当更新的高度$h&lt;=min(lh,rh)$时，显然不用更新；当$h&gt;=max(lh,rh)$时，直接更新整段区间；否则继续划分区间。于是最后更新的区间只有$O(logn)$段，单次询问复杂度也为$O(logn)$。 与标算一样，也需要考虑$P​$改变后对答案的影响（要修改到新的$[P,P’]​$或$[P’,P]​$），我就是因为没有判断$P​$与$P’​$的位置关系，导致爆0…QAQ… 相比标算，虽然更为麻烦，但是却能够支持区间查询。 7.6-动态规划及贪心作为NOIP必考的DP，难度普遍偏高，需要我们多多总结模型和一些优化的方法。 动态规划的要素，优化方法阶段 可划分，无后效性 ，背包、区间、树形，倍增，正序 - 逆序。 状态 状态数少，状态的“线性相关”，二进制压缩，舍弃无用状态。 权值 能比较，字典序，前缀和（最大值），可行性-&gt;判定性。 转移 效率要有保证 ，决策单调，斜率优化，数据结构 7.7-树状数据结构二叉堆 UOJ130：求$K$叉哈夫曼树的最小权，和权值最小时树的最小高度。 直接用堆维护哈夫曼树的叶子节点和，每次取出最小的$K$个子树，合并即可。由于要求高度最小，每次挑高度最小的合并。 51Nod1380：有$n$个排成环的数，每次可以选择一个数，同时删除这个数两边的数，直到所有数全部取完。问取出的数的和最大为多少。$n&lt;=100000$ 很赞的题目。用堆维护最大值，选取最大值后删除两边的值。发现这样不一定是最优的，需要能够“撤销”操作。考虑将最大值位置的值修改为左右两边的和减去中间的数重新入堆。当再次选到这个位置上时，就会撤销原来的操作，加上了新的值。当多次选到这个位置上时，会撤销之前的撤销操作，不难发现，每次选择的个数刚好加一。于是入$n/3$次堆就可以直接跳出了。 注意到需要标记每个元素是否被删除。直接用一个$bool$数组维护的话，需要每次找左端和右端的数，复杂度可能退化到$O(n^2)$。于是用双向链表维护一下就行了。 有一长为$N$的序列$A$， 给出$L,R$，计算所有长度在$[L, R]$的区间的和中，最小的$m$个数之和。 显然先计算出前缀和。考虑在堆加入三元组$(l,r,i)$，表示右端点为$i$，左端点为$[l,r]$的某个数，时区间的最大和。每次挑出$[l,r]$中$s[j-1]$最小的$j$，之后再在堆中加入$(l,j-1,i)$以及$(j+1,r,i)$。需要求出区间最值，用ST表实现即可。 树状数组 常数较小，支持单点修改，维护前缀信息。 对于$C[i]$，维护的是$[i-lowbit(i)+1,i]$的信息。 容易扩展到高维的情形。 通过差分处理，可以进行区间修改。 因为$lowbit(x)=lowbit(-x)$，把数组投影到$[-n,-1]$，所以加减的顺序改变后，事实上求的是树状数组后缀和。 51Nod1461：给定$n$个数$li$，删除$li$需要$di$的能量。假设剩下$k$个数，如果最大$li$的数量超过$⌊n/2⌋$，那么这$k$个数是稳定的。求使得剩下的数稳定所需要的最小能量。$n&lt;=100000$ 考虑按照$li$递增排序，每次处理一段相同的$li$（假设有$m$个）。于是我们就要从比$li$小的$lj$中挑选$m-1$个$di$最大的数。离散化$di$，就可以用树状数组维护最大的前缀和。可是如何找到第$m-1$大的数。考虑另外开一个树状数组，保存前缀$di$的个数。二分答案能在$O(logn \\times logn)$找出第$m-1$大值。 事实上，由于树状数组优美的结构，能够很好地支持倍增。假设目前已经到了第$p$位，前缀个数为$s$个，对于逐个减小的$k$，若$s+sum[p+1,p+2^k]&lt;=m-1$，则$p$就能增加到$p+2^k$。发现$sum[p+1,p+2^k]=sum[p+2^k-lowbit(p+2^k)+1,p+2^k]=c[p+2^k]$。 线段树区间修改的要求： 节点的信息是可以合并的。 并且信息可以和标记合并。 标记可以和标记合并。 线段树分治结构利用。基于均摊的线段树操作实现。 UOJ228：维护一个序列。支持：区间累加，区间开根，区间求和。$n,m&lt;=100000$ 当区间内开根后，减小的数都相同，就变成区间减操作。通过一些均摊复杂度分析，复杂度为$O(nlognloglogn)$？ CF438D：维护一个序列，支持：区间取模，单点修改，区间求和。$n,m&lt;=100000$ 考虑到如果区间的最大值小于模数，直接可以返回。复杂度分析：每次取模后，每个数至多变为原来的一半，单点加法每次也只恢复了一个点的势能，而势能是最多减少$log$次。 Trie Cow Xor：有一长为N的序列挑一段$[l, r]$使得$a[l]\\ xor\\ a[l+1]\\ xor … xor\\ a[r]$最大。 求出其前缀异或，插入$Trie$，贪心地询问$s[i]$异或最大值。 7.9-膜你赛2题目很赞，很滋瓷。T1可以无视，T2写出正解，T3是50分暴力。。全场Rank2？？ B:数据结构 给你一个长度为$𝑛$且下标从$1$开始的数列$a$。并给$𝑚$个操作。操作有两种：$1\\ 𝑝\\ 𝑥$，$𝑎𝑝=𝑥$。$2\\ 𝑎\\ 𝑏$，求$Σ︀𝐹(𝑖, 𝑗)(a&lt;=i&lt;=j&lt;=b)。$其中$F(i,j)=ai\\ xor\\ ai+1\\ xor … xor\\ aj$。 $n,m&lt;=10^5,0&lt;=ai,x&lt;=1000$ 考虑到对于每一位二进制位都是异或独立的，所以对于十个二进制位用十个线段树维护。发现区间对于答案有贡献，当且仅当区间内恰好有奇数个一。 考虑维护四个值：$cnt$:区间内点的个数；$sum$:区间内恰有奇数个点的子区间个数；$L$:有奇数个1的前缀个数；$R$:有奇数个1的后缀个数。 首先$cnt​$很容易维护。对于$L​$，只需要把左端的$L​$与右端的合并，如果左端$cnt​$为偶数，那么就要加上右端的$L​$否则加上区间长度减$L​$（即有偶数个1的前缀个数）。$R​$也是同样。于是我们很容易用$L​$和$R​$维护$sum​$。首先要加上左端和右端的$sum​$，再考虑跨过中心的情况，分为左奇右偶和左偶右奇相乘即可。 C:组合数学 $A$、$B$、$C$有一叠卡，$A$有$𝑁$张，$B$有$𝑀$张，$C$有$𝐾$张。卡片上写着字母$A$，$B$或$C$，游戏从$A$开始。每个人把牌打出来，下个出牌的人的是打出的卡上的字母。如果当前玩家没有牌，那么那个玩家就赢了。求$A$能获胜的种类。 事实上，我们可以把出牌的次序看作一个序列（一个持牌情况肯定对应唯一一个序列）。发现当$A$出现第$N$次后，$A$就赢了。并且此前，$B$最多出现$M$次，$C$最多出现$K$次。我们考虑枚举第$N$个$A$出现的位置，假设是$x$。首先确定前$N-1$个$A$出现的位置，为$C_{x-1}^{N-1}$。考虑到剩下的位置可一随机排放$A$,$B$或$C$，还要乘上$3^{N+M+K-x}$。于是枚举$B$的个数，可以的到算得$C$的个数。复杂度$O(N^2)$就能得到50分。 考虑满分的做法。画出杨辉三角，可以发现由于$M$和$K$的个数限制，得到的是一块平行四边形区域。考虑如何维护每一行的值，如果没有限制，前一行乘2就可以得到下一行的和。发现有可能会超过平行四边形的边界，暴力减除即可。于是每一行的转移只需要$O(1)$，总的复杂度为$O(N)$。 7.10-图论相关由于Cyani太弱了，所以图论的题基本不会，只能另开一篇了。。。 7.12~13-NOIP模拟赛一Day1&amp;Day2两场比赛完炸，只有100+100+10+100+80+0=390分。代码能力还是不够。 形态形成场 给定前$k$个大写字母的替换式$Si$，会出现大写字母和数字。求字符$A$所代表的串中有多少子串满足：子串为单个字符’0’或没有前导’0’，且把子串看作十进制数后模$n$等于0。 显然，我们可以按照拓扑序依次求出每个字符所代表的答案。 考虑如何合并两个区间的答案。假设我们需要将$a$和$b$合并为$c$，于是我们需要求出跨过中间的数的贡献。发现即为$a$的后缀$x$，与$b$的前缀$y$所合并的数$(x\\times 10^{leny}+y)\\ mod\\ n=0$。于是我们需要维护前缀$pre$[$i$]，与后缀$suf$[$i,j$]（ 保存$10^{leny}\\ mod\\ n$与$y\\ mod\\ n$）。为了维护前缀和后缀，还需要维护区间模$n$的值$val$与$10^{len}$模$n$的值。区间的合并类似线段树。 旅行商 旅行商要参加一些展销会（都在河的旁边，可以不参加），给定展销会的时间（只有一天），地点，收益，顺流和逆流行驶要一定的成本，可瞬间到达。求最大收益。 若展销会不在同一天，就是简单的$O(n^2)$DP。考虑一天参加多个展销会的情况。发现参加的展销会一定是一段连续区间，于是从之前的状态转移到现在的每个展销会，再同层状态向左或向右转移。非同层状态转移$O(n^2)$，同层状态转移$O(n^2)$，总的复杂度$O(n^2)$。 LEBOXES 有$n$个盒子，每个盒子有$Pi$的概率为$ \\$Vi$，否则为一颗钻石。有$m$个物品，每个物品需要$ \\$Ai$和$Bi$个钻石。打开箱子，买下尽可能多的物品。求购买物品的期望数。$n,m&lt;=30$ 预处理$f(i,j)$表示用至多$i$个钻石，买$j$个物品最少要花多少钱。这样就做到时间复杂度与$Ai,Vi$无关。同时观察数据范围可知，应该是折半搜索，再合并前后两段的答案。 爆搜可以得到前后两端获得若干钻石的钱数和概率，可以存在vector里。假设前一段钻石数$j$，后一段钻石数$k$，能买$i$个物品。发现对于不同的$(j,k)$，对于答案的贡献是独立的，于是我们需要分别求得概率$g(j,k,i)$。考虑到随着$i$的变小，$g(j,k,i)$变大，而$g(j,k,i)-g(j,k,i+1)$才是最多买$i$个的概率。 考虑如何求得$g(j,k,i)$。我们需要钱数$A(j,x)+B(k,y)&gt;=f(j+k,i)$，于是我们可以将之前的到的vector数组排序+求前缀和。于是我们只需移动指针$x$的同时，指针$y$也单调移动就行了。 考虑复杂度。枚举$i,j$为$O(nm)$，而$O(\\Sigma |B_k|)=O(2^{n/2})$。所以总的复杂度为$O(nm\\times 2^{n/2})$。 7.16~17-NOIP模拟赛一Day1&amp;Day2怎么说呢，题目比之前水，所以才有100+30+100+100+100+70=500。全场Rank5？ 压路机 在一个$n\\times m$的网格中，你需要从起点到终点。给定每条边所需的时间，其中出发后，结束前，改变方向前后都需要双倍的时间。求最少时间。$n,m&lt;=100$ 很显然的最短路。同时加上2维状态，表示之前的方向，以及之前的道路是否已经计算两次。相当于把一个点裂成5个点。直接跑Dijkstra或SPFA即可。 有一个坑点 直观上认为，走回头路一定是更劣的，于是一堆人被坑成30分；没有考虑的反而A了。事实上，假设有4个点$a,b,c,d$，有边$(a,b)$长1，边$(b,c)$长1，边$(b,d)$长100。如果不考虑，一定会选择$a\\rightarrow b\\rightarrow c$ ，代价为202；而如果$a\\rightarrow b\\rightarrow c\\rightarrow b\\rightarrow d$， 代价仅为104。 长城游戏 在$n\\times n$的棋盘上，有$n$个棋子。问最少移动几次，使得所有棋子在同一行或列。$n&lt;=6\\times 10^5$ 显然，如果我们要移到同一行，我们需要移到不同的列。类似均分纸牌一样，$O(n)$扫一边即可。 由于我太傻了，直接枚举都移到某一行或列，先排序，然后维护前缀和，前缀个数之类的东西。$O(n)$扫一边，比较出最优解。 事实上，一定是取中位数最优（初一都知道的常识）。。有位dalao取了平均数233。。。 历史 有个奇怪的王国，有$n$座城市。每年，在位的国王都会修建一条路$x&lt;=&gt;y$。有时候，国王闲得无聊就会计划一次$st\\rightarrow ed$的旅行，如果当前能完成这次旅行而$t$年前不能，国王就会高兴，否则会生气。并让下次旅行之前，建设的道路$x&lt;=&gt;y$错误地记为$(x+n-c)\\ mod\\ n&lt;=&gt;(y+n-c)\\ mod\\ n$。其中会发生国王的交替，初始国王的c为0，每个国王的c或许各不相同。求每次旅行计划，国王是否满意。$n,m&lt;=3\\times 10^5$ 显然并查集，由于要查询历史信息（可持久化并查集？233），考虑离线的做法。事实上我们只要把之后的询问挂在之前的时间上，直接计算即可。 考虑在线的做法。事实上就是要求两个点所在路径中，最后加边的时间。考虑到并查集的形态不能被破环，所以可以按秩合并。树高只有$O(logn)$，暴力向上爬求LCA即可。复杂度$O(nlogn)$。以上纯属口胡。。。 尾声半个月的集训结束了，可以说是收获颇丰。学到了很多，复习了很多知识，但也认识到自己的很多不足。这不是小学生的流水帐吗。。 在模拟赛中，由于做题心切，一心想打正解，导致正解打挂甚至根本没调出来。 先写暴力，再打正解，是比较稳妥的方式。 时间分配也要合理，留出充足的时间检查。 平时训练的时候，总是要交很多次才能A。没有很好地考虑到所有情况，小错误也比较多。 没有静下心来写，导致效率偏点。 差不多就是这些吧。以后也不会再更新了。反正继续加油~~","tags":[{"name":"集训","slug":"集训","permalink":"https://cyanie.github.io/tags/集训/"}]},{"title":"AtCoder比赛记录&题解","date":"2017-07-01T14:00:00.000Z","path":"2017/07/01/AtCoder/","text":"未完成: ARC#078E/F, AGC#018B/C/D/E/F, ARC#079F ARC#080E/F 比赛记录2017年 比赛名称 AC/提交/总数 Rank AtCoder Regular Contest 077 2/3/4 144 AtCoder Regular Contest 078 2/2/4 477 AtCoder Grand Contest 018 1/2/6 549 AtCoder Regular Contest 079 3/3/4 261 AtCoder Regular Contest 080 2/3/4 674 题解AtCoder Regular Contest 077 D - 11 给定$n$和长度为$n+1$的子序列，每个数都在$[1,n]$，且恰有一个数出现两次。对于$k=1,2,…,n+1$，求出长度为$k$的互异子序列个数。$n&lt;=10^5$ 首先找出相同的两个数$x$的位置$l,r$，可以发现剩下的数都是等价的。对于每个$k$，分类讨论计数。按照选取$x$个数，就是$C{n-1}^k+2C{n-1}^{k-1}+C{n-1}^{k-2}$。注意到，如果在$(l,r)$内没有选数，选择$l$和选择$r$会被当作同一情况，于是答案还要减去$C{u+v}^{k-1}$。 E - guruguru 有一盏灯具有$1,2,…,m$种亮度。遥控板可以一次操作可以将亮度加一（为$m$时，变为$1$）或跳转到固定的亮度$x$。一开始亮度为$a1$，接下来$n-1$次，你需要将亮度从$a{i-1}$调节到$a_i$。选取一个$x$，使得调节的总次数最小。$n,m&lt;=10^5$ 记$f(x_0)$为：当$x=x_0$时，需要调节的总次数。考虑亮度$s\\Rightarrow t$ 对$f(x)$的贡献（假设$s&lt;t$， 其他情况同样处理）。 对于$x&lt;=s$，$f(x)+=t-s$ 对于$s&lt;x&lt;=t$， $f(x)+=t-x+1$ 对于$t&lt;x$，$f(x)+=t-s$ 发现是区间操作，并且只有在最后查询。于是考虑差分，特别的，需要分为常数部分和系数部分。 F - SS 定义“双串”，由两个相同的字符串拼接而成。定义$f(S)$，在双串S后追加最少字符得到的双串。给定$S0S0$和$l,r$。求$f^{10^{100}}(S0S0)$在$[l,r]$内，26个字母分别出现的个数。$|S|&lt;=2*10^5,l,r&lt;=10^{18}$ 有待更深入理解。用KMP预处理Next[]，可以的到S0的最短相同前后缀T，设$f(S0S0)=STST$。通过画图发现，若$|T|$是$|S|$的因数，那么S就是由一些T拼成的，$f(STST)=STTSTT$。否则，$f(STST)=STSTST$。设$g(S)g(S)=f(SS)$ ，能得到$g^{i+2}(S)=g^{i+1}(S)+g^i(S)$（显然，对于$i$无限大时也满足第一种情况）。考虑求出前缀的贡献，按照类似fib数列的递推方式计算即可。 AtCoder Regular Contest 078 D - Fennec VS. Snuke 有一棵有$n$个节点的树，A和B在树上玩涂色游戏。一开始，$1$号节点被涂上黑色，$n$号节点被涂上白色，其他节点没有被涂色。A和B轮流进行操作，不能继续操作的玩家输。对于A，能选择一个与被涂黑节点相邻的节点（未涂色）涂上黑色。B是对称的操作。 对于每个玩家，首要考虑的圈占尽可能多的地盘。于是一定先在$1\\rightarrow n$的路径上涂色，直到相遇。剩下未涂色的节点谁多，谁就获胜。一般地，我们可以转化为以$1$为根的有根树，找到路径$1\\rightarrow n$的中点$p$，比较$size(p)$与$n-size(p)$的大小即可。 AtCoder Grand Contest 018我太弱了，根本不会做啊啊啊啊。。。。 AtCoder Regular Contest 079","tags":[{"name":"比赛","slug":"比赛","permalink":"https://cyanie.github.io/tags/比赛/"}]},{"title":"CodeForces比赛记录&题解","date":"2017-07-01T02:00:00.000Z","path":"2017/07/01/CodeForces/","text":"未完成: 818G, 822E/F, 828D/E/F, 835E/F, 837D/F/G, 838C/D/F, 839E, 834C/D/E 831F 比赛记录2017年 比赛名称 AC/提交/总数 Rank Educational Codeforces Round 24 4/5/7 144 (虚拟) Codeforces Round #422 (Div. 2) 4/4/6 111 Codeforces Round #423 (Div. 2, rated, based on VK Cup Finals) 2/3/6 520 Codeforces Round #427 (Div. 2) 4/4/6 93 Educational Codeforces Round 26 4/5/7 77 IndiaHacks 2nd Elimination 2017 2/3/6 27 Codeforces Round #428 (Div. 2) 2/4/5 477 (虚拟) Codeforces Round #424 (Div. 2, rated, based on VK Cup Finals) 5/5/6 38 (虚拟)Codeforces Round #426 (Div. 2) 2/3/5 807 题解Educational Codeforces Round 24D:【题意】给定n个数${c1,c2…}$和A，用$cntX(i)$表示${c1,c2,…,ci}$中等于X的数。询问是否存在B，使得对于任意i，都有$cntB(i)&gt;=cntA(i)$。 【题解】考虑一个个枚举B，首先判定$cntB(n)$是否不小于$cntA(n)$ 。发现答案的条件等价于：一个个比较A和B所在的位置，对于所有第i次出现的A，都满足第i个出现的B在前面。假设A的个数为m，则每次判断为$O(m)$，而满足前提的B的个数为$O(n/m)$ ，复杂度$O(n)$ 。 E:【题意】给定n个数${a1,a2…}$和k，问存在多少有序数对$(x,y)$满足：删除前x个数和后y个数，剩下数的乘积是k的倍数。 【题解】将k质因数分解（最多有10个不同的质因子），只要每个质因子的个数达到k拥有的就可以了。直接暴力枚举左端区间，发现右区间有单调性，直接维护一个滑动窗口就好了（比赛时写了二分233…）。 F:【题意】很好玩的题。 有q组询问，每组询问给出数n。问n个节点最多能连多少条边，使得桥的数量不少于总边数的一半。 【题解】有个很显然的结论：n个节点构成的图中桥不超过n-1个。因为无向图可以看一些树连一些边构成的，而n节点数恰好只有n-1个桥，连上的边一定不会成为桥。考虑这样构造：中间构造一个“K-完全图“，剩余的节点就往“完全图“上连单一的边，不难发现这样是存在k个桥时，边数最多的方案。 实际上，内部的图最多只有$min(n-k, \\frac{k(k-1)}{2}) $ 条边，于是总边数为$f(k)=n-k+min(n-k, \\frac{k(k-1)}{2}) $ 发现这个函数$f(k)$ 是个单峰函数，用三分法求解（最值两边有严格单调性）即可。 三分法的正确姿势。 ${Lmid=(2l+r)/3}~~~{Rmid=(l+2r)/3}$ ，当L和R差小于3后，暴力找出最值。 (坑)G：网络流难题。","tags":[{"name":"比赛","slug":"比赛","permalink":"https://cyanie.github.io/tags/比赛/"}]},{"title":"Hello World!","date":"2017-06-30T16:00:00.000Z","path":"2017/07/01/Hello-World!/","text":"博主是ZJSX某蒟蒻。 小学连续三年水了市里的一等，感觉什么都没学。 初一PJ差10分一等，还是我太弱了 初二PJ侥幸385。20+人并列，一定是题目太水了 ZJOI2017，一试30分，二试70分。伪装成神犇？ 现在初三，正在为TG和ZJOI2018而努力，一起加油吧~ 大事记UPD 2017.7.25 BZOJ 100AC 纪念。 UPD 2017.8.17 我的心路历程。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://cyanie.github.io/tags/随笔/"}]}]