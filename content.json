[{"title":"Burnside引理与Polya定理","date":"2017-08-05T12:05:00.000Z","path":"2017/08/05/Algorithms-Group-theory/","text":"更多的坑待填… 参考资料 说明 在OI中群论主要用于等价类计数，其中Burnside引理与Polya定理是其核心。 一些定义及定理群。群$G$是一个定义在二元组$(S,⋅)$的代数结构，$⋅$是一个二元运算符。满足封闭性(任两个元素能推到另一个元素)，结合律，消去律。存在单位元$e$，并且每个元素都有逆元。 置换。$(a_1,a_2,a_3,…,a_n)$即$(1,2,3,4,…,n)$的一一映射（全排列），把$i$映射到$a_i$。任意一个置换都可以写成循环的形式：$(3,5,1,4,2)=(1\\ 3)(2\\ 5)(4)$。 置换群，即由置换组成的群，运算是置换的连接。 Burnside引理。用于求置换下的等价类个数。设$G={f_1,f2,…f{|G|}}$是$[1,n]$的置换群。一个方案$S$在置换$f$的作用下不变，称$S$为$f$的不动点，$fi$的不动点个数记为$c(i)$。于是，$$\\Large ans=\\frac{\\sum {i=1}^{|G|} c(i)}{|G|}$$。 Polya定理。 如果置换$f$分解为$m(f)$个循环，每个循环的颜色都相同，若存在$k$种颜色，即有$c(i)=k^{m(f)}$。带入Burnside引理即得。 一些推论及技巧$c(i)$可以通过组合计数，DP或数论的方式求出。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://cyanie.github.io/tags/笔记/"}]},{"title":"prufer序列与矩阵树定理","date":"2017-08-04T10:00:00.000Z","path":"2017/08/04/Algorithms-Tree-count/","text":"更多的坑待填… prufer序列参考资料 prufer序是无根树的编码表示，对于一棵$n$个节点带编号的无根树，对应唯一一串长度为$n-2$的prufer编码。 无根树转化为prufer序列找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下$2$个节点。 根据以上过程，显然有推论 一个节点的度数=其在prefer序列出现的次数+1。 prufer序列转化为无根树首先prufer序列中的出现次数+1可以得到每个节点的度。 先执行$n-2​$步，选取最小标号度为1的点$u​$与Purfer序列的第$i​$个数$v​$表示的顶点相连，并将$u​$和$v​$的度减$1​$。最后再把剩下的两个度为$1​$的点连边。 由此发现，一棵无根树和与一个prufer序列一一对应。 一些推论 一个无向完全图的生成树个数为$n^{n-2}$。 设节点$i$的度数限制为$di$，求满足条件树的个数。对应到prufer序列，相当于$i$在序列中出现了$di-1$次，不同的排列数。即为$n!$除以每个$(di-1)!$。 对于一些没有限制度数，稍微修改一下即可。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://cyanie.github.io/tags/笔记/"}]},{"title":"AtCoder泛做-ARC#068~076","date":"2017-07-14T16:00:00.000Z","path":"2017/07/15/Training-ARC-068-076/","text":"未完成: ARC#069F, ARC#070E/F, ARC#074E/F AtCoder Regular Contest 068 E - Snuke Line 给定$n$个区间$[l,r]$和一个数$m$。对于$d=1,2,3…,m$，求$kd(1&lt;=kd&lt;=m,k\\in Z)$被多少个不同区间覆盖（对于不同的$k$，只算一次）。$1&lt;=n,m&lt;=3\\times 10^5,1&lt;=l&lt;=r&lt;=m$ 记区间的长度为$len=r-l+1$。想到可以$O(mlogm)$暴力枚举所有的$kd$，用线段树算出它被几个区间包含。容易发现当$d&lt;len$时，有可能被多次计算。 考虑当$d&lt;=len$时，则一定存在$k$使得$kd$被这个区间覆盖。于是我们记录满足$d&lt;=len$的区间个数即可。而对于$d&gt;len$的情况，至多有一个$kd$被区间覆盖，于是就可以用线段树维护。即当$d&gt;len$时加入这个区间，同时单点询问$kd$被多少个区间覆盖。复杂度$O((mlogm+n)logm)$。 Code F - Solitaire 有一个双端队列，依次往首或尾插入数1到n。然后你可以从队列的首或位取出一个数，顺次相接组成一个序列。求有多少个序列的第$K$位为$1$？$1&lt;=k&lt;=n&lt;=2\\times 10^3$ 显然，当$n$个数全部插入后，队列一定是递减到1再递增的。不难发现，得到的序列的前$K$位，一定是由两个递减序列交错得到的，且第$K$位为1。 从$n$到$1$逐个考虑每一个数是否选择，且属于哪一个序列。定义$f(i,j)$ 已经得到了序列的前$i$位，其中第$i$位为$j$的方案数。将$j$加入序列1，则$f(i,j)$可由$f(i-1,k), k&gt;j$转移过来。 如果将新的数加入序列2，该如何转移？可以发现，这个数一定是没选择的数中最大的数（序列2也是递减的）。则$f(i,j)$可由$f(i-1,j)$转移过来。 事实上，DP的过程还有一个非法的转移。$f(K-1,1)$会转移到$f(K,1)$，不是以1作为第$K$个数。 对于剩下的$n-K$个数，每次可以取头或尾。于是答案$ans=(f(K-1,1)-f(K-1,1))\\times 2^{n-K-1}$。 时间复杂度$O(nK)$。 Code AtCoder Regular Contest 069 E - Frequency 有$n$堆石头，第$i$堆有$ai$个石头。每一次，你需要记录下石头最多的堆的序号（当石头数相同时，取最左端的），然后你可以从某堆中拿走一块石头。直到石头被全部拿走。需要使得序号组成的序列字典序最小，问1到n在序列中出现的次数。 可以发现，这个序列一定是非递增的。假设现在最多的石头堆为$x$，在1到x-1中石头最多的堆为$y$。考虑贪心的过程，我们需要把x到n中，石头数大于$ay$都取到$ay$，因为这样能使得序号尽可能快地减小。离散化石头数，再从小到大考虑，用树状数组维护小于某个值的石头堆数量，以及石头数总和即可。 事实上，存在排序后$O(n)$的做法。 Code F - Flags 你在一条线上插$n$个$flag$，其中第$i$个$flag$可以插在$xi$或$yi$。记所有$flag$两两间的距离最小值为$d$，求$d$的最大值。 暂未编写。 考虑二分答案$d$。于是是否放在$xi,yi$变成了$2-SAT$判定性问题，对于$xi$和$yi$恰好放一个，距离小于$d$的位置不能同时放，构成了一些约束条件。暴力枚举所有点对，可以在$O(n^2logMAX_{x})$的时间内解决。 发现许多约束条件是无用的。考虑类似线段树的分治结构来建图，对于每个点，至多与$O(logn)$个区间相连；令一方面，线段树中父子相连的边也只有$O(n)$条。单次判定的复杂度可以做到$O(nlogn)$。总的时间复杂度$O(nlognlogMAX_{x})$，可以通过此题。 存在$O(n(logn+logMAX_x))$的算法，暂未理解。 AtCoder Regular Contest 070 D - Need 给定$n$个数$ai$。如果存在子集满足其和大于等于$K$，则称为是好的子集。如果一个数$ai$所在的所有好集中，去除$ai$后仍是好集，则$ai$是无用的。求无用的数的个数。 对于$x&lt;y$，若$y$是无用的，则$x$一定无用的，所以答案满足单调性。考虑判断$x$是否是无用的，用$bitset$维护$n-1$个数相加能组成的集合（$x$除外，可以用类似$DP$的方式求出）。 显然，如果其他的数能组成$K-x$到$K-1$中的任意一个数，则$x$是有用的。时间复杂度$O(\\frac {n^2logn} w)$ ，此处$w$一般为$32$或$64$。 Code AtCoder Regular Contest 071 E - TrBBnsformBBtion 有字符串$S,T$，仅由$A$或$B$构成。有如下操作：①选择一个字符:$A\\rightarrow BB$ 或 $B\\rightarrow AA$。②删除连续3个相同的字符:$AAA$或$BBB$。给定$Q$个询问，对于每个询问，回答$S[a,b]$能否变换为$T[c,d]$。$|S|,|T|,Q&lt;=10^5$ 想了几分钟就YY了一个结论：把A看作1，把B看作2，两个串能变换当且仅当两个区间和模3同余。然后就A掉了。首先，必要性显然，因为对于区间和模3，不论如何操作都不会改变。 看了官方题解才知道如何证明充分性。首先主要到所有的操作都是可逆的：$A\\rightarrow BB\\rightarrow AAAA\\rightarrow A$。且$A,B$可以任意地加3个或减3个。考虑将$S$和$T$中的$B$全变为$A$。如果$S,T$的$A$个个数关于3同余，则一定能变换。就证明了结论。 Code F - Infinite Sequence 给定$n\\ (n&lt;=10^6)$，问存在多少个无穷序列满足：1.每个数都在1到$n$之间。2.对于任意$n&lt;=i,j$，都有$a_i=a_j$。3.对于任意的$i$，若存在$i+1&lt;=j&lt;k&lt;=i+a_i$，都有$a_j=a_k$。 发现只有前$n$位是有用的，考虑到动态规划更容易向前转移，定义$f(i)$为子序列$[i,n]$满足条件的个数，于是我们考虑$a_i$的值即可转移。 发现1是一个比较特殊的数，当$a_i=1$时，$f(i)=f(i-1)$。 当$a[i]\\not=1,a[i+1]\\not=1$时，序列为$ABBBBBB…$的形式，$f(i)=(n-1)\\times (n-1)$。 当$a[i]\\not=1,a[i+1]=1$时，序列为$A,1,1,,..,1,B…$的形式，$f(i)=f(i-3)+f(i-4)+…+f(1)+n-i+2$。 Code AtCoder Regular Contest 072 D - Alice&amp;Brown A和B在玩一个游戏。一开始，有两堆石子分别有$X$和$Y$个。你可以从一堆中取$2i$个，然后放$i$个到另一堆。无法操作的玩家输。问先手是否存在必胜策略?$0&lt;=X,Y&lt;=10^{18}$。 通过打表发现，当$|X-Y|&gt;=2$先手必胜，否则后手必胜。考虑如何证明。 对于$(X,Y)=(0,0),(0,1),(1,0),(1,1)$，满足$|X-Y|&lt;=1$，是必败态。 对于必胜态，设$|X-Y|=3k+r&gt;=2\\ (r=0,1,-1,\\ k&gt;=1)$ ，取$i=k$，即可转移到必败态。 对于必败态，操作后$X-Y$至少改变3，一定会转移到必胜态。 Code E - Alice in linear land 给定长度为$n$的操作序列$ai$和距离$di$。对于每个$ai$，当$|d-ai|&lt;d$时$|d-ai|$会成为新的$d$，若最终$d=0$，则称是可达的。给定$Q$个询问$qi$，问能否改变$a[qi]$，使得操作序列是不可达的？$n,Q&lt;=5\\times 10^5$ 首先可以预处理前缀$a[1,qi-1]$操作后的$d$，记为$pre[qi-1]$。发现对于询问$qi$，只需要知道后缀$a[qi+1,n]$使得序列不可达的最小的$d=suf[qi+1]$，只要$pre[qi-1]&gt;=suf[qi+1]$就一定能做到。 于是问题转化为如何就$suf[i]$。显然，$suf[n+1]=1$，而且随着$i$的减小，$suf[i]$一定是非递减的。当$ai&gt;=2\\times suf[i+1]$，可以取到$suf[i]=suf[i+1]$（此时无法执行操作）；否则$suf[i]=suf[i+1]+ai$。 Code F - Dam 有一个水坝容积为$L$，一开始没有水。此后$n$天，在第$i$天早晨，会进来体积为$Vi$，温度为$Ti$的水；为了下一天水不会溢出，第$i$天傍晚需要排出一些水 Code","tags":[{"name":"训练","slug":"训练","permalink":"https://cyanie.github.io/tags/训练/"}]},{"title":"2017年7月NOIP集训总结","date":"2017-07-02T12:00:00.000Z","path":"2017/07/02/2017.7-Training/","text":"暑假终于到了，蒟蒻$Cyani$也要开始刷题啦~ 暑假的训练时光是宝贵的，是算法和思维快速提高的时期，在这里总结下收获。 7.2-基础数据结构单调栈&amp;单调队列单调栈应用： 求出一个数左/右第一个比这个数大/小的数。 BZOJ1136：[POI2009]求序列中的最长连续子序列，其平均数大于$k$。 考虑每个数都减去$k$，转化为区间和&gt;=0的最长区间。求前缀和后，若$i &gt; j$且$sum_i&gt;=sum_j$，则$j$作为左端点比$i$更优。 维护一个$i$递增$sum_i$递减的栈。枚举右端点，利用单调性二分找到小于它的节点。 事实上，右端点从$n$向左枚举，小于等于它的节点都可以弹出（右端点左移后，长度只会更劣）。 HDU5726：[多校2016]对于给定序列$A$，和$Q$组询问$(l,r)$。输出$gcd(al,al+1,…,ar)$ 和所有满足$gcd(al,al+1,…,ar)=gcd(al0,al0+1,…,ar0)$ 的$(l0,r0)$的个数。 $gcd$有一个很神奇的性质，不断对某个数取$gcd$，得到不同的值最多有$log$个。考虑右端点不断向右移，维护$gcd$区间的单调栈，加入新的数后不断合并相同的数。 考虑第一个问题，将所有询问挂在右端点，对于左端点排序，之后在单调栈里扫一遍就好了。 考虑第二个问题，用一个$map$存所有出现的$gcd$个数。单调栈同时保存所在下标，单调栈扫一遍，下标作差就是贡献。 51Nod1962：给出两个数组A，B，求$Σ︀max(Ai,Ai+1, …,Aj)==max(Bi , Bi+1, …,Bj)(1&lt;=i&lt;=j&lt;=n)$的值。 暂未AC。向右移动一个端点时，前一次的答案可以利用。维护单调栈时，也维护区间即可。 单调队列应用: 维护DP决策点，删除不可能的决策。 CF524F：给出一个仅由’(‘和‘)’构成的字符串，现在可以加入一个字符，或者将末尾的字符移到最前面。求一个长度最短的合法括号序列，如果有多个输出长度最短的且字典序最小。 暂未完全理解。这题的正解是后缀数组或者HASH+二分，复杂度$O(nlogn)$，然而我并不会。然后zyy大神犇用单调队列，(si hu)复杂度$O(n)$就过去了，做法还是很神的。首先答案一定是原长加上两种括号的差值，（这个是一定能完成的，并且’(‘加在最前面，’)’加在最后面）。那么我们可以将串倍长，计算每个长度为n的区间是否将会缩成一种括号。 考虑计算那些为位置可以作为左端点，如果说一个括号序列是可以匹配的，当且仅当“所有位置的前缀’(‘数量大于’)’的数量“。维护’)’与’(‘差值的前缀和单调递减，每次可以找到’)’减去’(‘最大的右端点，若这个值大于要加上的左括号的数量，则这个位置开始是不符的。$O(n)$内就能算出每个位置是否能作为左端点。 接下来就是些很神奇(sang xing bing kuang)的操作，比较以这些左端点所在的区间的字典序，乱搞一下就行了？复杂度又似乎$O(n^2)$？反正没搞懂。。 字符串这一部分考的主要是KMP的灵活应用和对$Nex$t数组的理解（如经典的把匹配位置作为状态的DP）。 CF631D：给出两个串$A$,$B$，问$B$在$A$中出现了多少次。字符串由$n$个二元组$(li,ci)$拼接而成，每个二元组代表$li$个字符$ci$。 考虑去除$B$前后的二元组，中间的用KMP匹配，两边的再特殊判断。特判只有一个或两个二元组的的情况。 Hash原来我对哈希的理解仅在”一堆数加起来模个质数”的层面。。 把所有数据都$xor$起来，这种方法适用于数据不需要维持相对顺序的时候。 转化成一个$seed$进制下的数模一个质数的值，是可以支持询问一个区间的值，拼接若干区间，以及插入，删除，修改之后的全局询问。 CF7D：定义一个串是$k$回文的，当且仅当这个串是回文的，且其长为$⌊n/2⌋$的前后缀都是$k − 1$回文的，任意串都是$0$回文的。判断这个串的每个前缀的最大回文数. 考虑直接DP。如果$[1,i]$是回文的就有$fi=f{i/2}$，否则为0。考虑维护左端和右端的HASH值，用第二种方式可在两端插入和删除，判断是否相等即可。 CF452F：给定一个$n$的置换$A$，问是否存在一个三元等差子序列。 哈希+线段树。对于中间的数$x$，若不存在$x-k$和$x+k$构成了等差数列，则$x-k$和$x+k$一定在都在$x$之前或之后。于是维护以出现的数，若出现的数关于$x$不对称，一定存在一个等差数列。用线段树正反各维护HASH的值，判断是否相等即可。用第二种HASH方式。 差分这是NOIP喜欢考的小技巧。 序列差分，将区间加变成单点加减，只能做到离线。 树上差分，一般和LCA结合。在u,v处打标记，在LCA处消除标记，求其子树的标记和即可。对于一些树上路径问题，可以用差分代替树链剖分。 BZOJ3043：给定数列A，每次可将区间+1或-1。至少多少次使得所有数相同，在此条件下最终的数列有多少种。 将所有数差分，可将题目中的区间加减变为单点加减。考虑差分的性质：若要操作$[l,r]$，当$r$不为$n$时，在$l$处打$+1/-1$标记，在$r+1$处打$-1/+1$；仅当$r=n$时，在$l$处打$+1/-1$。于是求出差分数组正数的和$x$，负数的和的绝对值$y$。然后$x,y$互相抵消，多余的自己抵消或和第一个抵消。操作次数为$max(x,y)$，结果数为$abs(x-y)+1$。 树上差分的经典题：[NOIP2015]D1T3运输计划，[JLOI2014]松鼠的新家 7.3-树相关1倍增倍增也是noip的常考点，往往可以优化为$log$或去掉一个$log$。 假设现在有问题$f(N)$，如果我们可以通过$f(A)$和$f(B)$快速求出$f(A+B)$，则我们就可以倍增。二进制拆分为$log$个答案，再合并就是最终答案。e.g.快速幂，多项式乘法(FFT?)，RMQ求区间最值，树上节点的祖先。 优化二分。对于一些具有单调性的问题，我们可以二分答案，再用倍增求，复杂度$O(lognlogn)$ 。事实上可以用倍增优化二分，复杂度降到$O(logn)$ 。 假设二分的区间是$[0,n]$，设$m=log(n)$。 设答案$ans$一开始为0，先检验$ans+2^m$是否满足条件，如果满足则让$ans+=2^m$。 之后让$m–$，一直做到$m=0$为止。 正确性显然，相当于二进制逐位确定最终的$ans$。 利用倍增估计二分的界限，来优化一些奇怪的二分？ HDU4343：给定$n$个区间，有$m$次询问，每次问最多可以从n个区间中选出多少$[L,R]$的子区间，使得他们互不相交。 首先去除包含其它区间的区间（显然选择更小的区间更优），所以左端点和右端点都是递增。考虑贪心的过程，每次要选择左端点&gt;=当前右端点，且最靠左的区间。预处理所有区间的后继，然后算出倍增数组。对于每个询问，找到区间内最靠左的区间，倍增找到最靠右的区间，每次询问复杂度$O(logn)%$。 HDU6031：给定一棵$n$个点的有根树，有$Q$次询问，每次询问给出一个集合$A$和集合$B$，你需要从$A$中选出一个数$x$，从$B$中选出一个数$y$，使得$lca(x,y)$的深度最大。 二分答案的深度$s$，求出$A$中点的深度为$s$的祖先和$B$中点的深度为$s$的祖先。用$map$判断两个集合是否有交即可。 DFS序把对子树维护的问题转成对区间维护的问题，记录DFS进入和出去的时间。$y$在$x$的子树中的充要条件是：$in[x]&lt;=in[y]&lt;=out[y]&lt;=out[x]$。 转化为区间维护问题后，用树状数组或线段树维护即可。一般难度不大。 树的路径相关 将路径拆分为x到$LCA$，和$LCA$到y的两条链。 定义一个点的重量是去掉它之后树的最大的联通块的大小。我们将一棵树中重量最小的点称为重心。一棵树最多只有两个重心。 判断无根树同构：取重心作为根，从而变成有根树，然后就可以用树hash来判断是否同构了。 点分治：重心的重量一定小于等于$n/2$，所以可以用来分治。 定义一棵树中最长的路径为树的直径。树的直径并不唯一，但是直径的中点都是一样的。 任选一个点$S$，找到离他最远的点$X$。找到离$X$最远的点$Y$。那么$(X,Y)$就是一条直径。 直径合并：对于两棵树$T,S$，任取他们的直径$(Ta,Tb)$，$(Sa,Sb)$。假设现在有一条边连接了$T$和$S$，构成了新的树$M$，那么$(Ta,Tb,Sa,Sb)$这四个点中一定能选出两个点$u,v$，使得$(u,v)$是$M$的一条直径。 对于一些要你在树上选两个点的题，可以先打表看看，很大概率是选在直径上最优。 并查集 路径压缩：与树的形态无关，尽量将儿子节点挂到根节点上，均摊复杂度$O(α(n))$，单次可能被卡到$O(n)$！ 按秩合并：与树的形态有关，记一下每棵有根树的子树大小，每次合并时让小的成为大的的儿子。树高一定是$O(logn)$。复杂度证明：从一个点x出发，每次往上爬，子树大小至少翻一倍。所以最多爬$O(logn)$次。 CF468B：给定$a,b$和$n$个整数。每个整数属于集合$A$或$B$。如果$x$属于集合$A$，那么$a-x$也属于集合$A$；如果$x$属于集合$B$，那么$b-x$也属于集合$B$。判断是否冲突 考虑其逆否命题，$a-x\\notin A\\Rightarrow x\\notin A$ ，可以确定某些整数能否属于集合$A$，集合$B$同样处理。同时将$x$与$a-x$合并，或上1表示能在集合$A$，或上2表示能在集合$B$。最后判断同一个并查集里的是否有冲突即可。 7.5-膜你赛1题目很赞，数据略水，还是很滋瓷的。T1暴力A掉，T2写出正解，T3正解写挂。。全场Rank5？？ A:分块 给定序列$a1,a2,…,an$和$Q$个询问。对于询问$(q,p)$求出所有满足$i=p(mod\\ q)$的$ai$之和。$n,Q&lt;=100000$ 暴力对于数据随机，均摊复杂度可以达到$O(nlogn)$（调和级数）。 发现暴力速度的瓶颈在于$q$较小的情况。考虑设置一个阀值$k$。 对于$q&gt;=k$的情况，直接$O(n/k)$就可以暴力算出答案。 对于$q&lt;k$的情况，$O(kn)$就可以预处理答案。 复杂度$O(kn+n^2/k)$，显然取$k=\\sqrt n$最优。 B:函数相关？脑洞题 给定一个$n$行$m$列的矩阵（所有的元素都在模$K$意义下操作），可以有以下操作：修改某一行，使得这行所有的数累加1；列也是类似操作。求出最少要操作几次，使得矩阵全为0（保证存在解）。$n,m&lt;=1000$ 假设第$i$行的操作次数为$xi$，第$j$列的操作次数为$yj$。显然$0&lt;=xi,yj&lt;K$。 不难发现当第一行的操作次数（记为$x$）确定后，所有行和列的操作次数都能确定，且都是关于$x$的线性函数。 所以操作次数$ans=f(x)$是关于$x$的分段函数，每一段都是一次函数。 发现一次函数的最值一定是在端点处取到，而端点取到的情况是某个$xi$或$yj$等于$K-1$或$0$。 带入$x$，直接$O(n)$就能算出$f(x)$，于是复杂度为$O(n^2)$。 C:数据结构 有$𝑛$个墙，第$𝑖$个墙的高度为$𝑎𝑖$，给你$𝑄$个操作。$𝑃$，询问当前墙的状态下最多能存储多少水。$𝑈(𝑥,𝑣)$，令第$x$个墙的高度增加$v$。$n,Q&lt;=100000$ 考虑暴力的做法。为了方便计算，我们需要把砖块当作“水”，同时维护砖块的个数。显然我们一定可以找到最高且最靠右的墙（记为$P$），而左边水的高度是单调不减的，右边水的高度是单调不增的。 直接$O(1)$维护墙的高度。对于每一个询问，从$1$扫描到$P$，维护前缀最大值，每个位置水的高度都是前缀最大值；同理从$n$扫描到$P+1$即可。需要减去砖块的个数。 标程的做法：以$P$左侧为例。用$set$维护高度递增的墙。当$x$高度增加需要更新后，弹出在$x$右侧且比它低的墙，在此同时，维护水的个数即可。注意到$P$位置是可以改变的，需要特殊处理。由于进入$set$的元素个数为$O(n)$，并且$set$单次操作时间为$O(logn)$。复杂度$O(nlogn)$。 我的做法：用线段树维护。当$x$的高度增加需要更新后，区间更新$[x,P]$的最大值。即仅当$ax&gt;ai(x&lt;=i&lt;=P)$后，才会更新$ai$的值。似乎需要$O(n)$？ 事实上，由于单调性的存在，对于每个线段树区间$[l,r]$，维护左端高度$lh$，右端高度$rh$。当更新的高度$h&lt;=min(lh,rh)$时，显然不用更新；当$h&gt;=max(lh,rh)$时，直接更新整段区间；否则继续划分区间。于是最后更新的区间只有$O(logn)$段，单次询问复杂度也为$O(logn)$。 与标算一样，也需要考虑$P​$改变后对答案的影响（要修改到新的$[P,P’]​$或$[P’,P]​$），我就是因为没有判断$P​$与$P’​$的位置关系，导致爆0…QAQ… 相比标算，虽然更为麻烦，但是却能够支持区间查询。 7.6-动态规划及贪心作为NOIP必考的DP，难度普遍偏高，需要我们多多总结模型和一些优化的方法。 动态规划的要素，优化方法阶段 可划分，无后效性 ，背包、区间、树形，倍增，正序 - 逆序。 状态 状态数少，状态的“线性相关”，二进制压缩，舍弃无用状态。 权值 能比较，字典序，前缀和（最大值），可行性-&gt;判定性。 转移 效率要有保证 ，决策单调，斜率优化，数据结构 7.7-树状数据结构二叉堆 UOJ130：求$K$叉哈夫曼树的最小权，和权值最小时树的最小高度。 直接用堆维护哈夫曼树的叶子节点和，每次取出最小的$K$个子树，合并即可。由于要求高度最小，每次挑高度最小的合并。 51Nod1380：有$n$个排成环的数，每次可以选择一个数，同时删除这个数两边的数，直到所有数全部取完。问取出的数的和最大为多少。$n&lt;=100000$ 很赞的题目。用堆维护最大值，选取最大值后删除两边的值。发现这样不一定是最优的，需要能够“撤销”操作。考虑将最大值位置的值修改为左右两边的和减去中间的数重新入堆。当再次选到这个位置上时，就会撤销原来的操作，加上了新的值。当多次选到这个位置上时，会撤销之前的撤销操作，不难发现，每次选择的个数刚好加一。于是入$n/3$次堆就可以直接跳出了。 注意到需要标记每个元素是否被删除。直接用一个$bool$数组维护的话，需要每次找左端和右端的数，复杂度可能退化到$O(n^2)$。于是用双向链表维护一下就行了。 有一长为$N$的序列$A$， 给出$L,R$，计算所有长度在$[L, R]$的区间的和中，最小的$m$个数之和。 显然先计算出前缀和。考虑在堆加入三元组$(l,r,i)$，表示右端点为$i$，左端点为$[l,r]$的某个数，时区间的最大和。每次挑出$[l,r]$中$s[j-1]$最小的$j$，之后再在堆中加入$(l,j-1,i)$以及$(j+1,r,i)$。需要求出区间最值，用ST表实现即可。 树状数组 常数较小，支持单点修改，维护前缀信息。 对于$C[i]$，维护的是$[i-lowbit(i)+1,i]$的信息。 容易扩展到高维的情形。 通过差分处理，可以进行区间修改。 因为$lowbit(x)=lowbit(-x)$，把数组投影到$[-n,-1]$，所以加减的顺序改变后，事实上求的是树状数组后缀和。 51Nod1461：给定$n$个数$li$，删除$li$需要$di$的能量。假设剩下$k$个数，如果最大$li$的数量超过$⌊n/2⌋$，那么这$k$个数是稳定的。求使得剩下的数稳定所需要的最小能量。$n&lt;=100000$ 考虑按照$li$递增排序，每次处理一段相同的$li$（假设有$m$个）。于是我们就要从比$li$小的$lj$中挑选$m-1$个$di$最大的数。离散化$di$，就可以用树状数组维护最大的前缀和。可是如何找到第$m-1$大的数。考虑另外开一个树状数组，保存前缀$di$的个数。二分答案能在$O(logn \\times logn)$找出第$m-1$大值。 事实上，由于树状数组优美的结构，能够很好地支持倍增。假设目前已经到了第$p$位，前缀个数为$s$个，对于逐个减小的$k$，若$s+sum[p+1,p+2^k]&lt;=m-1$，则$p$就能增加到$p+2^k$。发现$sum[p+1,p+2^k]=sum[p+2^k-lowbit(p+2^k)+1,p+2^k]=c[p+2^k]$。 线段树区间修改的要求： 节点的信息是可以合并的。 并且信息可以和标记合并。 标记可以和标记合并。 线段树分治结构利用。基于均摊的线段树操作实现。 UOJ228：维护一个序列。支持：区间累加，区间开根，区间求和。$n,m&lt;=100000$ 当区间内开根后，减小的数都相同，就变成区间减操作。通过一些均摊复杂度分析，复杂度为$O(nlognloglogn)$？ CF438D：维护一个序列，支持：区间取模，单点修改，区间求和。$n,m&lt;=100000$ 考虑到如果区间的最大值小于模数，直接可以返回。复杂度分析：每次取模后，每个数至多变为原来的一半，单点加法每次也只恢复了一个点的势能，而势能是最多减少$log$次。 Trie Cow Xor：有一长为N的序列挑一段$[l, r]$使得$a[l]\\ xor\\ a[l+1]\\ xor … xor\\ a[r]$最大。 求出其前缀异或，插入$Trie$，贪心地询问$s[i]$异或最大值。 7.9-膜你赛2题目很赞，很滋瓷。T1可以无视，T2写出正解，T3是50分暴力。。全场Rank2？？ B:数据结构 给你一个长度为$𝑛$且下标从$1$开始的数列$a$。并给$𝑚$个操作。操作有两种：$1\\ 𝑝\\ 𝑥$，$𝑎𝑝=𝑥$。$2\\ 𝑎\\ 𝑏$，求$Σ︀𝐹(𝑖, 𝑗)(a&lt;=i&lt;=j&lt;=b)。$其中$F(i,j)=ai\\ xor\\ ai+1\\ xor … xor\\ aj$。 $n,m&lt;=10^5,0&lt;=ai,x&lt;=1000$ 考虑到对于每一位二进制位都是异或独立的，所以对于十个二进制位用十个线段树维护。发现区间对于答案有贡献，当且仅当区间内恰好有奇数个一。 考虑维护四个值：$cnt$:区间内点的个数；$sum$:区间内恰有奇数个点的子区间个数；$L$:有奇数个1的前缀个数；$R$:有奇数个1的后缀个数。 首先$cnt​$很容易维护。对于$L​$，只需要把左端的$L​$与右端的合并，如果左端$cnt​$为偶数，那么就要加上右端的$L​$否则加上区间长度减$L​$（即有偶数个1的前缀个数）。$R​$也是同样。于是我们很容易用$L​$和$R​$维护$sum​$。首先要加上左端和右端的$sum​$，再考虑跨过中心的情况，分为左奇右偶和左偶右奇相乘即可。 C:组合数学 $A$、$B$、$C$有一叠卡，$A$有$𝑁$张，$B$有$𝑀$张，$C$有$𝐾$张。卡片上写着字母$A$，$B$或$C$，游戏从$A$开始。每个人把牌打出来，下个出牌的人的是打出的卡上的字母。如果当前玩家没有牌，那么那个玩家就赢了。求$A$能获胜的种类。 事实上，我们可以把出牌的次序看作一个序列（一个持牌情况肯定对应唯一一个序列）。发现当$A$出现第$N$次后，$A$就赢了。并且此前，$B$最多出现$M$次，$C$最多出现$K$次。我们考虑枚举第$N$个$A$出现的位置，假设是$x$。首先确定前$N-1$个$A$出现的位置，为$C_{x-1}^{N-1}$。考虑到剩下的位置可一随机排放$A$,$B$或$C$，还要乘上$3^{N+M+K-x}$。于是枚举$B$的个数，可以的到算得$C$的个数。复杂度$O(N^2)$就能得到50分。 考虑满分的做法。画出杨辉三角，可以发现由于$M$和$K$的个数限制，得到的是一块平行四边形区域。考虑如何维护每一行的值，如果没有限制，前一行乘2就可以得到下一行的和。发现有可能会超过平行四边形的边界，暴力减除即可。于是每一行的转移只需要$O(1)$，总的复杂度为$O(N)$。 7.10-图论相关由于Cyani太弱了，所以图论的题基本不会，只能另开一篇了。。。 7.12~13-NOIP模拟赛一Day1&amp;Day2两场比赛完炸，只有100+100+10+100+80+0=390分。代码能力还是不够。 形态形成场 给定前$k$个大写字母的替换式$Si$，会出现大写字母和数字。求字符$A$所代表的串中有多少子串满足：子串为单个字符’0’或没有前导’0’，且把子串看作十进制数后模$n$等于0。 显然，我们可以按照拓扑序依次求出每个字符所代表的答案。 考虑如何合并两个区间的答案。假设我们需要将$a$和$b$合并为$c$，于是我们需要求出跨过中间的数的贡献。发现即为$a$的后缀$x$，与$b$的前缀$y$所合并的数$(x\\times 10^{leny}+y)\\ mod\\ n=0$。于是我们需要维护前缀$pre$[$i$]，与后缀$suf$[$i,j$]（ 保存$10^{leny}\\ mod\\ n$与$y\\ mod\\ n$）。为了维护前缀和后缀，还需要维护区间模$n$的值$val$与$10^{len}$模$n$的值。区间的合并类似线段树。 旅行商 旅行商要参加一些展销会（都在河的旁边，可以不参加），给定展销会的时间（只有一天），地点，收益，顺流和逆流行驶要一定的成本，可瞬间到达。求最大收益。 若展销会不在同一天，就是简单的$O(n^2)$DP。考虑一天参加多个展销会的情况。发现参加的展销会一定是一段连续区间，于是从之前的状态转移到现在的每个展销会，再同层状态向左或向右转移。非同层状态转移$O(n^2)$，同层状态转移$O(n^2)$，总的复杂度$O(n^2)$。 LEBOXES 有$n$个盒子，每个盒子有$Pi$的概率为$ \\$Vi$，否则为一颗钻石。有$m$个物品，每个物品需要$ \\$Ai$和$Bi$个钻石。打开箱子，买下尽可能多的物品。求购买物品的期望数。$n,m&lt;=30$ 预处理$f(i,j)$表示用至多$i$个钻石，买$j$个物品最少要花多少钱。这样就做到时间复杂度与$Ai,Vi$无关。同时观察数据范围可知，应该是折半搜索，再合并前后两段的答案。 爆搜可以得到前后两端获得若干钻石的钱数和概率，可以存在vector里。假设前一段钻石数$j$，后一段钻石数$k$，能买$i$个物品。发现对于不同的$(j,k)$，对于答案的贡献是独立的，于是我们需要分别求得概率$g(j,k,i)$。考虑到随着$i$的变小，$g(j,k,i)$变大，而$g(j,k,i)-g(j,k,i+1)$才是最多买$i$个的概率。 考虑如何求得$g(j,k,i)$。我们需要钱数$A(j,x)+B(k,y)&gt;=f(j+k,i)$，于是我们可以将之前的到的vector数组排序+求前缀和。于是我们只需移动指针$x$的同时，指针$y$也单调移动就行了。 考虑复杂度。枚举$i,j$为$O(nm)$，而$O(\\Sigma |B_k|)=O(2^{n/2})$。所以总的复杂度为$O(nm\\times 2^{n/2})$。 7.16~17-NOIP模拟赛一Day1&amp;Day2怎么说呢，题目比之前水，所以才有100+30+100+100+100+70=500。全场Rank5？ 压路机 在一个$n\\times m$的网格中，你需要从起点到终点。给定每条边所需的时间，其中出发后，结束前，改变方向前后都需要双倍的时间。求最少时间。$n,m&lt;=100$ 很显然的最短路。同时加上2维状态，表示之前的方向，以及之前的道路是否已经计算两次。相当于把一个点裂成5个点。直接跑Dijkstra或SPFA即可。 有一个坑点 直观上认为，走回头路一定是更劣的，于是一堆人被坑成30分；没有考虑的反而A了。事实上，假设有4个点$a,b,c,d$，有边$(a,b)$长1，边$(b,c)$长1，边$(b,d)$长100。如果不考虑，一定会选择$a\\rightarrow b\\rightarrow c$ ，代价为202；而如果$a\\rightarrow b\\rightarrow c\\rightarrow b\\rightarrow d$， 代价仅为104。 长城游戏 在$n\\times n$的棋盘上，有$n$个棋子。问最少移动几次，使得所有棋子在同一行或列。$n&lt;=6\\times 10^5$ 显然，如果我们要移到同一行，我们需要移到不同的列。类似均分纸牌一样，$O(n)$扫一边即可。 由于我太傻了，直接枚举都移到某一行或列，先排序，然后维护前缀和，前缀个数之类的东西。$O(n)$扫一边，比较出最优解。 事实上，一定是取中位数最优（初一都知道的常识）。。有位dalao取了平均数233。。。 历史 有个奇怪的王国，有$n$座城市。每年，在位的国王都会修建一条路$x&lt;=&gt;y$。有时候，国王闲得无聊就会计划一次$st\\rightarrow ed$的旅行，如果当前能完成这次旅行而$t$年前不能，国王就会高兴，否则会生气。并让下次旅行之前，建设的道路$x&lt;=&gt;y$错误地记为$(x+n-c)\\ mod\\ n&lt;=&gt;(y+n-c)\\ mod\\ n$。其中会发生国王的交替，初始国王的c为0，每个国王的c或许各不相同。求每次旅行计划，国王是否满意。$n,m&lt;=3\\times 10^5$ 显然并查集，由于要查询历史信息（可持久化并查集？233），考虑离线的做法。事实上我们只要把之后的询问挂在之前的时间上，直接计算即可。 考虑在线的做法。事实上就是要求两个点所在路径中，最后加边的时间。考虑到并查集的形态不能被破环，所以可以按秩合并。树高只有$O(logn)$，暴力向上爬求LCA即可。复杂度$O(nlogn)$。以上纯属口胡。。。 尾声半个月的集训结束了，可以说是收获颇丰。学到了很多，复习了很多知识，但也认识到自己的很多不足。这不是小学生的流水帐吗。。 在模拟赛中，由于做题心切，一心想打正解，导致正解打挂甚至根本没调出来。 先写暴力，再打正解，是比较稳妥的方式。 时间分配也要合理，留出充足的时间检查。 平时训练的时候，总是要交很多次才能A。没有很好地考虑到所有情况，小错误也比较多。 没有静下心来写，导致效率偏点。 差不多就是这些吧。以后也不会再更新了。反正继续加油~~","tags":[{"name":"集训","slug":"集训","permalink":"https://cyanie.github.io/tags/集训/"}]},{"title":"AtCoder比赛记录&题解","date":"2017-07-01T14:00:00.000Z","path":"2017/07/01/AtCoder/","text":"未完成: ARC#078E/F, AGC#018B/C/D/E/F, ARC#079F 比赛记录2017年 比赛名称 AC/提交/总数 Rank AtCoder Regular Contest 077 2/3/4 144 AtCoder Regular Contest 078 2/2/4 477 AtCoder Grand Contest 018 1/2/6 549 AtCoder Regular Contest 079 3/3/4 261 题解AtCoder Regular Contest 077 D - 11 给定$n$和长度为$n+1$的子序列，每个数都在$[1,n]$，且恰有一个数出现两次。对于$k=1,2,…,n+1$，求出长度为$k$的互异子序列个数。$n&lt;=10^5$ 首先找出相同的两个数$x$的位置$l,r$，可以发现剩下的数都是等价的。对于每个$k$，分类讨论计数。按照选取$x$个数，就是$C{n-1}^k+2C{n-1}^{k-1}+C{n-1}^{k-2}$。注意到，如果在$(l,r)$内没有选数，选择$l$和选择$r$会被当作同一情况，于是答案还要减去$C{u+v}^{k-1}$。 E - guruguru 有一盏灯具有$1,2,…,m$种亮度。遥控板可以一次操作可以将亮度加一（为$m$时，变为$1$）或跳转到固定的亮度$x$。一开始亮度为$a1$，接下来$n-1$次，你需要将亮度从$a{i-1}$调节到$a_i$。选取一个$x$，使得调节的总次数最小。$n,m&lt;=10^5$ 记$f(x_0)$为：当$x=x_0$时，需要调节的总次数。考虑亮度$s\\Rightarrow t$ 对$f(x)$的贡献（假设$s&lt;t$， 其他情况同样处理）。 对于$x&lt;=s$，$f(x)+=t-s$ 对于$s&lt;x&lt;=t$， $f(x)+=t-x+1$ 对于$t&lt;x$，$f(x)+=t-s$ 发现是区间操作，并且只有在最后查询。于是考虑差分，特别的，需要分为常数部分和系数部分。 F - SS 定义“双串”，由两个相同的字符串拼接而成。定义$f(S)$，在双串S后追加最少字符得到的双串。给定$S0S0$和$l,r$。求$f^{10^{100}}(S0S0)$在$[l,r]$内，26个字母分别出现的个数。$|S|&lt;=2*10^5,l,r&lt;=10^{18}$ 有待更深入理解。用KMP预处理Next[]，可以的到S0的最短相同前后缀T，设$f(S0S0)=STST$。通过画图发现，若$|T|$是$|S|$的因数，那么S就是由一些T拼成的，$f(STST)=STTSTT$。否则，$f(STST)=STSTST$。设$g(S)g(S)=f(SS)$ ，能得到$g^{i+2}(S)=g^{i+1}(S)+g^i(S)$（显然，对于$i$无限大时也满足第一种情况）。考虑求出前缀的贡献，按照类似fib数列的递推方式计算即可。 AtCoder Regular Contest 078 D - Fennec VS. Snuke 有一棵有$n$个节点的树，A和B在树上玩涂色游戏。一开始，$1$号节点被涂上黑色，$n$号节点被涂上白色，其他节点没有被涂色。A和B轮流进行操作，不能继续操作的玩家输。对于A，能选择一个与被涂黑节点相邻的节点（未涂色）涂上黑色。B是对称的操作。 对于每个玩家，首要考虑的圈占尽可能多的地盘。于是一定先在$1\\rightarrow n$的路径上涂色，直到相遇。剩下未涂色的节点谁多，谁就获胜。一般地，我们可以转化为以$1$为根的有根树，找到路径$1\\rightarrow n$的中点$p$，比较$size(p)$与$n-size(p)$的大小即可。 AtCoder Grand Contest 018我太弱了，根本不会做啊啊啊啊。。。。 AtCoder Regular Contest 079","tags":[{"name":"比赛","slug":"比赛","permalink":"https://cyanie.github.io/tags/比赛/"}]},{"title":"CodeForces比赛记录&题解","date":"2017-07-01T02:00:00.000Z","path":"2017/07/01/CodeForces/","text":"未完成: 818G, 822E/F, 828D/E/F, 835E/F, 837D/F/G 比赛记录2017年 比赛名称 AC/提交/总数 Rank Educational Codeforces Round 24 4/5/7 144 (虚拟)Codeforces Round #422 (Div. 2) 4/4/6 111 Codeforces Round #423 (Div. 2, rated, based on VK Cup Finals) 2/3/6 520 Codeforces Round #427 (Div. 2) 4/4/6 93 Educational Codeforces Round 26 4/5/7 77 题解Educational Codeforces Round 24D:【题意】给定n个数${c1,c2…}$和A，用$cntX(i)$表示${c1,c2,…,ci}$中等于X的数。询问是否存在B，使得对于任意i，都有$cntB(i)&gt;=cntA(i)$。 【题解】考虑一个个枚举B，首先判定$cntB(n)$是否不小于$cntA(n)$ 。发现答案的条件等价于：一个个比较A和B所在的位置，对于所有第i次出现的A，都满足第i个出现的B在前面。假设A的个数为m，则每次判断为$O(m)$，而满足前提的B的个数为$O(n/m)$ ，复杂度$O(n)$ 。 E:【题意】给定n个数${a1,a2…}$和k，问存在多少有序数对$(x,y)$满足：删除前x个数和后y个数，剩下数的乘积是k的倍数。 【题解】将k质因数分解（最多有10个不同的质因子），只要每个质因子的个数达到k拥有的就可以了。直接暴力枚举左端区间，发现右区间有单调性，直接维护一个滑动窗口就好了（比赛时写了二分233…）。 F:【题意】很好玩的题。 有q组询问，每组询问给出数n。问n个节点最多能连多少条边，使得桥的数量不少于总边数的一半。 【题解】有个很显然的结论：n个节点构成的图中桥不超过n-1个。因为无向图可以看一些树连一些边构成的，而n节点数恰好只有n-1个桥，连上的边一定不会成为桥。考虑这样构造：中间构造一个“K-完全图“，剩余的节点就往“完全图“上连单一的边，不难发现这样是存在k个桥时，边数最多的方案。 实际上，内部的图最多只有$min(n-k, \\frac{k(k-1)}{2}) $ 条边，于是总边数为$f(k)=n-k+min(n-k, \\frac{k(k-1)}{2}) $ 发现这个函数$f(k)$ 是个单峰函数，用三分法求解（最值两边有严格单调性）即可。 三分法的正确姿势。 ${Lmid=(2l+r)/3}~~~{Rmid=(l+2r)/3}$ ，当L和R差小于3后，暴力找出最值。 (坑)G：网络流难题。","tags":[{"name":"比赛","slug":"比赛","permalink":"https://cyanie.github.io/tags/比赛/"}]},{"title":"Hello World!","date":"2017-06-30T16:00:00.000Z","path":"2017/07/01/Hello-World!/","text":"博主是ZJSX某蒟蒻。 小学连续三年水了市里的一等，感觉什么都没学。 初一PJ差10分一等，还是我太弱了 初二PJ侥幸385。20+人并列，一定是题目太水了 ZJOI2017，一试30分，二试70分。伪装成神犇？ 现在初三，正在为TG和ZJOI2018而努力，一起加油吧~ UPD 2017.7.25 BZOJ 100AC 纪念。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://cyanie.github.io/tags/随笔/"}]}]